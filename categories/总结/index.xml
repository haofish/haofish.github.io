<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>总结 on 🐟🐟🐟&lt;--</title>
    <link>https://haofish.github.io/categories/%E6%80%BB%E7%BB%93/</link>
    <description>Recent content in 总结 on 🐟🐟🐟&lt;--</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 25 Jul 2020 19:08:51 +0800</lastBuildDate>
    
	<atom:link href="https://haofish.github.io/categories/%E6%80%BB%E7%BB%93/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>贪心刷题总结</title>
      <link>https://haofish.github.io/2020/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 25 Jul 2020 19:08:51 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>前言 总结 普通贪心 区间贪心  前言  终于开始刷贪心了，感觉cf很多题都喜欢出贪心，所以决定也练练 贪心貌似也有挺系统的分类和一些经典例题，把这些刷了应该就有提升了把  总结  贪心是指将问题通过当前最优解来求解得到最终的最优解，即局部最优解可以推出总体最优解。 给我的感觉就是一种思维题，通过一定技巧把题目旁敲侧击地解决了，但是如果没接触过或者想不出来，基本就很难了，但是贪心的代码实现并不长，所以说贪心即使很基础的算法也是很难的算法。 总得来说贪心算法难就难在每道题的贪心策略都不同，是否能贪心也很难看出来。 一般在解决贪心题的时候可以把他放到生活中的例子来，想想如果是生活中碰到这题，你会怎么解决让自己最舒服。  普通贪心   【例题】
  HDU 2111 Saving HDU
 题意：你有可以装k个宝贝容量的包，现在给你一些宝贝，每个宝贝价值p，有m个，问你最多可以装多少价值的宝贝 思路：将价值排序，先选大的，选到v = 0为止 代码如下  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;utility&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; int n, v; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;v), v) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; for (int i = 0; i &amp;lt; n; i++) { int p, m; scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;p, &amp;amp;m); q.</description>
    </item>
    
    <item>
      <title>图论刷题总结</title>
      <link>https://haofish.github.io/2020/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 21 Jul 2020 22:22:01 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>前言 总结 最短路  Dijkstra Bellman-Ford Floyd Spfa   未完待续  前言  起因是一次力扣周赛时被一道最短论的题给整蒙了，决定这几天恶补图论，正好POJ的刷题题单刷到了图 打算学习图论从零开始，目前刷的题不多  总结  关于存图  不同的存图方式可以使得不同的算法更加方便，例如：邻接表可以使Dijkstra算法在堆优化中方便不少，而邻接矩阵可以使Floyd算法更加方便   关于建图  有一些题目在描述的时候给的数据不好建图，这需要经验的积累 而有一些题目并没有直接说明是图，换句话说能否看出是使用图论的知识来解题也需要经验的累积   关于计算  题目中的要求并不是一成不变的，有时候最短路径并不是仅仅指的是值最短，有时候也有可能题目让你求最大值，但最短路依然可以解    最短路  先从最短路开始刷，刷到后面发现有些题三个算法（Dijkstra、Bellman-Ford、Floyd）都是可以解的  Dijkstra   [例题]
  洛谷P4779 【模板】单源最短路径（标准版）
 题意：最短路板子题，不解释 思路：直接用Dijkstra的堆优化做，因为没有负环 直接上代码  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;locale&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;utility&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef long long ll; typedef pair&amp;lt;int, int&amp;gt; pii; const int M = 2e5 + 10; const ll INF = 0x3f3f3f3f; int n, m, s, cnt = 0; struct edges { int w, to, next; edges(int a = 0, int b = 0, int c = -1) : w(b), to(a), next(c) {} }; vector&amp;lt;int&amp;gt; head, dis; vector&amp;lt;edges&amp;gt; edge; inline void add(int u, int v, int w) { edge[++cnt] = edges(v, w, head[u]); head[u] = cnt; } void dij() { vector&amp;lt;bool&amp;gt; vis(n + 1, false); dis = vector&amp;lt;int&amp;gt;(n + 1, INF); priority_queue&amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt; heap; dis[s] = 0; heap.</description>
    </item>
    
    <item>
      <title>模板</title>
      <link>https://haofish.github.io/2020/%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Mon, 13 Jul 2020 17:12:35 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/%E6%A8%A1%E6%9D%BF/</guid>
      <description>基础  二分 快速幂 最大公因数，最小公倍数 素数筛（埃式） 高精（不压位） 高精（压位） 离散化 未完待续……   数据结构  树状数组 线段树 dijkstra(堆优化版) bellman - ford floyd    基础 二分    二分分法：[l, mid) 和 [mid, r],目标值符合右区间及其端点    int bsearch(int l, int r){ while (l &amp;lt; r) { int mid = (long long)(l + r) &amp;gt;&amp;gt; 1;//相当于 l + r 后向下取整  if (/* 探针落在左区间 */) l = mid + 1; else r = mid; } return l; }   二分分法：[l, mid] 和 (mid, r], 目标值符合左区间及其端点    int bsearch(int l, int r){ while (l &amp;lt; r) { int mid = (long long)(l + r + 1) &amp;gt;&amp;gt; 1; //相当于 l + r 后向上取整，否则陷入死循环，例如 此时 l = 1, r = 2, 那么探针就会一直落到左区间 l 上（l + r &amp;gt;&amp;gt; 1 = 1），下一步 l = mid = l,就会死循环  if (/* 探针落在左区间 */) l = mid; else r = mid - 1; } return l; } 二分参考资料</description>
    </item>
    
    <item>
      <title>Dp总结</title>
      <link>https://haofish.github.io/2020/dp%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 01 Jul 2020 11:31:33 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/dp%E6%80%BB%E7%BB%93/</guid>
      <description>1. 写在前面的话 2. 对DP简单的总结 3. 几个重要的模型 4. 分类  ① 线性DP ② 区间DP ③ 树状DP  简介 【例题1】HDU 1520 Anniversary party 【例题2】HDU 2196 Computer   ④ 状态压缩DP  状态压缩简介 常见的二进制使用 【例题 1】HDU 方格取数（1） 【例题2】洛谷 P1879 Corn Fields G     5. 优化dp的手段  ① 矩阵优化 ② 数据结构优化 ③ 单调队列优化 ④ 决策单调性优化 ⑤ 二进制优化 ⑥ 斜率优化 ⑦ 四边形不等式优化    1. 写在前面的话  之前写了一篇不像总结的动态规划总结，感觉更像是一个成长历程，所以就打算重写一篇。  2. 对DP简单的总结   dp的题目特点</description>
    </item>
    
  </channel>
</rss>