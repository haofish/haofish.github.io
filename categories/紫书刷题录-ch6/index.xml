<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ç´«ä¹¦åˆ·é¢˜å½•-ch6 on ğŸŸğŸŸğŸŸ&lt;--</title>
    <link>https://haofish.github.io/categories/%E7%B4%AB%E4%B9%A6%E5%88%B7%E9%A2%98%E5%BD%95-ch6/</link>
    <description>Recent content in ç´«ä¹¦åˆ·é¢˜å½•-ch6 on ğŸŸğŸŸğŸŸ&lt;--</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 05 Aug 2020 10:12:16 +0800</lastBuildDate>
    
	<atom:link href="https://haofish.github.io/categories/%E7%B4%AB%E4%B9%A6%E5%88%B7%E9%A2%98%E5%BD%95-ch6/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>UVA10410</title>
      <link>https://haofish.github.io/2020/uva10410/</link>
      <pubDate>Wed, 05 Aug 2020 10:12:16 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva10410/</guid>
      <description>Tree Reconstruction  ç›´æ¥è¯´æ€è·¯ï¼šæ ˆçš„è¿ç”¨ï¼Œé¢˜ç›®è¯´è¾“å‡ºä»»æ„å¯èƒ½çš„ç­”æ¡ˆï¼Œæ‰€ä»¥æŠŠæ ‘å½“æˆä¸€ä¸ªäºŒå‰æ ‘æ¥åšï¼Œbfsæœ¬è´¨å°±æ˜¯æ ‘çš„ä¸€å±‚ä¸€å±‚çš„éå†ï¼Œå½“ä¸€ä¸ªèŠ‚ç‚¹åœ¨bfsåºä¸­ä¸‹æ ‡ä¸º $x$ï¼Œåˆ™ $x + 1$å¯ä»¥è®¤ä¸ºæ˜¯ä»–çš„å…„å¼ŸèŠ‚ç‚¹ï¼Œå…¶åé¢çš„éƒ½æ˜¯ä¸‹å±‚çš„èŠ‚ç‚¹ï¼›è€Œdfsçš„æœ¬è´¨æ˜¯ä¸€ä¸ªé“¾å¼çš„æ·±åº¦æœç´¢ï¼Œä¹Ÿå°±æ˜¯è¯´dfsä¸­è¿ç»­çš„å¾ˆå¯èƒ½å°±æ˜¯æ ‘çš„ä¸€æ¡é“¾å¼ã€‚æ ¹æ®ä»¥ä¸Šæ€§è´¨ï¼Œç”¨æ ˆæ¥æ¨¡æ‹Ÿdfsçš„å»ºé€ è¿‡ç¨‹ï¼Œå†æ›´å…·ä¸Šè¯‰bfsçš„æ€§è´¨æ¥åˆ¤æ–­æŸèŠ‚ç‚¹æ˜¯å¦æ˜¯æ ˆé¡¶çš„ä¸€ä¸ªå­èŠ‚ç‚¹ ä»£ç å¦‚ä¸‹  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int n, x; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  for (; ~scanf(&amp;#34;%d&amp;#34;, &amp;amp;n);) { vector&amp;lt;int&amp;gt; node[1010], dfs(n), bfs(n + 1); for (int i = 1; i &amp;lt;= n; i++) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); bfs[x] = i; } for (auto &amp;amp;i : dfs) scanf(&amp;#34;%d&amp;#34;, &amp;amp;i); stack&amp;lt;int&amp;gt; st; int root = dfs[0]; st.</description>
    </item>
    
    <item>
      <title>UVA806</title>
      <link>https://haofish.github.io/2020/uva806/</link>
      <pubDate>Tue, 04 Aug 2020 18:02:01 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva806/</guid>
      <description>Spatial Structures  æ¯’ç˜¤é¢˜  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; using ll = long long; int n, kase = 0; char g[70][70], m[70][70]; vector&amp;lt;ll&amp;gt; ans; void dfs(int r1, int c1, int r2, int c2, ll all, int d, int pos) { if (r1 == r2) { if (m[r1][c1] == &amp;#39;1&amp;#39;) ans.push_back(all + pos * pow(5, d - 1)); return; } int sum1 = 0, sum2 = 0, sum3 = 0, sum4 = 0; for (int i = r1; i &amp;lt;= (r2 + r1) / 2; i++) { for (int j = c1; j &amp;lt;= (c2 + c1) / 2; j++) { sum1 += m[i][j] - &amp;#39;0&amp;#39;; } } for (int i = r1; i &amp;lt;= (r2 + r1) / 2; i++) { for (int j = (c1 + c2) / 2 + 1; j &amp;lt;= c2; j++) { sum2 += m[i][j] - &amp;#39;0&amp;#39;; } } for (int i = (r1 + r2) / 2 + 1; i &amp;lt;= r2; i++) { for (int j = c1; j &amp;lt;= (c1 + c2) / 2; j++) { sum3 += m[i][j] - &amp;#39;0&amp;#39;; } } for (int i = (r1 + r2) / 2 + 1; i &amp;lt;= r2; i++) { for (int j = (c1 + c2) / 2 + 1; j &amp;lt;= c2; j++) { sum4 += m[i][j] - &amp;#39;0&amp;#39;; } } int sum = sum1 + sum2 + sum3 + sum4; ll x = 0; if (d) x = all + pos*pow(5, d - 1); if (sum == (r2 - r1 + 1) * (c2 - c1 + 1)) { if (x) ans.</description>
    </item>
    
    <item>
      <title>UVA804</title>
      <link>https://haofish.github.io/2020/uva804/</link>
      <pubDate>Tue, 04 Aug 2020 14:26:40 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva804/</guid>
      <description>Petri Net Simulation #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int p[110], np, nt, kase = 0; struct T { int in[110], out[110]; T() { memset(in, 0, sizeof in); memset(out, 0, sizeof out); } }; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  for (; scanf(&amp;#34;%d&amp;#34;, &amp;amp;np), np;) { for (int i = 1; i &amp;lt;= np; i++) { scanf(&amp;#34;%d&amp;#34;, p + i); } scanf(&amp;#34;%d&amp;#34;, &amp;amp;nt); int x; T ts[110]; for (int i = 1; i &amp;lt;= nt; i++) { for (; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x), x;) { if (x &amp;lt; 0) ts[i].</description>
    </item>
    
    <item>
      <title>UVA12166</title>
      <link>https://haofish.github.io/2020/uva12166/</link>
      <pubDate>Mon, 03 Aug 2020 20:27:46 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva12166/</guid>
      <description>Equilibrium Mobile  ç«Ÿç„¶æ˜¯ä¸€é“æ€ç»´é¢˜ï¼Œä¸è¡Œï¼Œè¿™é¢˜è¦å†™å†™é¢˜è§£ æ€è·¯ï¼š  å‡è®¾è¿™ä¸ªæ•°æ˜¯ä¸€ä¸ªæ»¡äºŒå‰æ ‘çš„ï¼Œå¹¶ä¸”æ¯ä¸ªå¶å­èŠ‚ç‚¹æ¯ä¸ªå¶å­èŠ‚ç‚¹çš„é‡é‡ï¼ˆæƒå€¼ï¼‰éƒ½ä¸ä¸€æ ·ï¼Œåˆ™æœ€å°‘çš„ä¿®æ”¹æ¬¡æ•°å°±æ˜¯ï¼šå¶å­èŠ‚ç‚¹æ•° - 1ï¼Œå…·ä½“ç­–ç•¥å°±æ˜¯æ‰¾ä¸€ä¸ªå¶å­èŠ‚ç‚¹ä¸ºåŸºå‡†ç‚¹ï¼Œè®¾å…¶é‡é‡ä¸º$x$ï¼Œç„¶åæŠŠå…¶ä½™çš„å¶å­èŠ‚ç‚¹çš„é‡é‡éƒ½ä¿®æ”¹æˆ$x$ï¼Œè®¾æ•°çš„æ·±åº¦ä¸º$h$ï¼Œåˆ™æ­¤æ—¶æ•´æ£µæ ‘çš„çš„é‡é‡ä¸º $x \times 2 ^ {h - 1}$ å¯¹äºå…¶ä»–æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®ä¸Šè¿°çš„ç‰¹æ®Šæƒ…å†µæ¥æ¨å¯¼ï¼Œå‡è®¾ä»¥æŸä¸ªå¶å­èŠ‚ç‚¹ä¸ºåŸºå‡†ç‚¹ï¼Œç„¶åè®¡ç®—ä¿®æ”¹åæ•´æ£µæ ‘çš„é‡é‡ï¼ˆæ ¹æ®å…¬å¼ $x \times 2 ^ {h - 1}$ï¼‰ æ‰€ä»¥ç­–ç•¥å°±æ˜¯ï¼Œè®¡ç®—æ¯ä¸ªå¶å­èŠ‚ç‚¹ä»¥å…¶ä¸ºåŸºå‡†ç‚¹ä¿®æ”¹åçš„æ•´æ£µæ ‘çš„é‡é‡ï¼Œè¿™æ ·è®¡ç®—ä¸‹å»ï¼Œå¯èƒ½ä¼šå‡ºç°è®¡ç®—ç»“æœç›¸åŒçš„æƒ…å†µï¼Œå°±æ„å‘³ç€ä»¥è¯¥å¶å­èŠ‚ç‚¹ä¸ºåŸºå‡†ç‚¹ä¿®æ”¹æ—¶ï¼Œæœ‰ä¸éœ€è¦ä¿®æ”¹çš„å¶å­èŠ‚ç‚¹ é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ç»Ÿè®¡ä»¥æ¯ä¸ªå¶å­èŠ‚ç‚¹ä¸ºåŸºå‡†ç‚¹ä¿®æ”¹åçš„æ•´æ£µæ ‘çš„é‡é‡çš„å€¼ï¼Œå‡ºç°æœ€å¤šæ¬¡æ•°çš„å°±è¯´æ˜ä»¥è¯¥å¶å­èŠ‚ç‚¹ä¸ºåŸºå‡†ç‚¹ä¿®æ”¹ï¼Œæœ‰æœ€å¤šçš„å¶å­èŠ‚ç‚¹ä¸éœ€è¦ä¿®æ”¹ï¼Œå›ºéœ€è¦ä¿®æ”¹çš„å¶å­èŠ‚ç‚¹ä¸ªæ•°æœ€å°‘ å‰©ä¸‹çš„å°±æ˜¯ä»£ç å®ç°äº†ï¼Œç”±äºé‡é‡å¯èƒ½å¾ˆå¤§ï¼Œå›ºç”¨å“ˆå¸Œæ¥å­˜æ”¾è¯¥é‡é‡çš„æ•°é‡   ä»£ç å¦‚ä¸‹  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; using ll = long long; int t, num; char str[1000005]; unordered_map&amp;lt;ll, int&amp;gt; myhash; void dfs(int l, int r, ll d) { if (str[l] == &amp;#39;[&amp;#39;) { int l_indx = l + 1, p = 0; while (l_indx &amp;lt; r) { if (str[l_indx] == &amp;#39;[&amp;#39;) p++; if (str[l_indx] == &amp;#39;]&amp;#39;) p--; if (p == 0) break; l_indx++; } int r_indx = strchr(&amp;amp;str[l_indx], &amp;#39;,&amp;#39;) - &amp;amp;str[l_indx] + l_indx; dfs(l + 1, l_indx, d + 1); dfs(r_indx + 1, r - 1, d + 1); return; } ll w = 0; sscanf(&amp;amp;str[l], &amp;#34;%lld&amp;#34;, &amp;amp;w); myhash[w * (1 &amp;lt;&amp;lt; d)]++; num++; } int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.</description>
    </item>
    
    <item>
      <title>UVA1600</title>
      <link>https://haofish.github.io/2020/uva1600/</link>
      <pubDate>Mon, 03 Aug 2020 16:26:13 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva1600/</guid>
      <description>Patrol Robot  BFSè¿›é˜¶é¢˜  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int n, m, g[25][25], t, k; const int dx[] = {-1, 0, 1, 0}; const int dy[] = {0, -1, 0, 1}; inline bool check(int x, int y) { return x &amp;gt;= 1 &amp;amp;&amp;amp; y &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n &amp;amp;&amp;amp; y &amp;lt;= m; } struct coo{ int x, y, d, k; coo(){} coo(int x, int y, int d, int k) : x(x), y(y), d(d), k(k){} }; void bfs() { queue&amp;lt;coo&amp;gt; q; bool vis[25][25][25] = {0}; vis[1][1][0] = g[1][1] == 1; q.</description>
    </item>
    
    <item>
      <title>UVA439</title>
      <link>https://haofish.github.io/2020/uva439/</link>
      <pubDate>Sun, 02 Aug 2020 16:15:00 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva439/</guid>
      <description>Knight Moves #include &amp;lt;bits/stdc++.h&amp;gt;#define mk(a, b) make_pair(a, b) using namespace std; using pii = pair&amp;lt;int, int&amp;gt;; using pdi = pair&amp;lt;pii, int&amp;gt;; int sx, sy, ex, ey; bool vis[10][10]; char a[5], b[5]; const int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2}; const int dy[] = {-1, -2, -2, -1, 1, 2, 2, 1}; inline bool cherk(int x, int y) { return x &amp;gt; 0 &amp;amp;&amp;amp; y &amp;gt; 0 &amp;amp;&amp;amp; x &amp;lt; 9 &amp;amp;&amp;amp; y &amp;lt; 9; } void print(int num) { printf(&amp;#34;To get from %s to %s takes %d knight moves.</description>
    </item>
    
    <item>
      <title>UVA536</title>
      <link>https://haofish.github.io/2020/uva536/</link>
      <pubDate>Sun, 02 Aug 2020 15:35:18 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva536/</guid>
      <description>Tree Recovery #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; char pre[30], in[30]; void dfs(int a, int b, int c, int d) { if (c &amp;gt; d) return; char tmp = pre[a]; int indx = c; while (in[indx] != tmp) indx++; dfs(a + 1, a + indx - c, c, indx - 1); dfs(a + indx - c + 1, b, indx + 1, d); printf(&amp;#34;%c&amp;#34;, tmp); } int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.</description>
    </item>
    
    <item>
      <title>UVA712</title>
      <link>https://haofish.github.io/2020/uva712/</link>
      <pubDate>Sun, 02 Aug 2020 14:41:02 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva712/</guid>
      <description>S-Trees  ä¸è€ƒè™‘å˜é‡çš„é¡ºåº  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int n, k, kase = 0;; char res[600], in[10]; void dfs(int indx, int x) { if (indx == n) { printf(&amp;#34;%c&amp;#34;, res[x - (1 &amp;lt;&amp;lt; n)]); return; } if (in[indx] == &amp;#39;0&amp;#39;) dfs(indx + 1, x &amp;lt;&amp;lt; 1); else dfs(indx + 1, x &amp;lt;&amp;lt; 1 | 1); } int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;n), n) { char tmp[10]; for (int i = 0; i &amp;lt; n; i++) { scanf(&amp;#34;%s&amp;#34;, tmp); } scanf(&amp;#34;%s&amp;#34;, res); printf(&amp;#34;S-Tree #%d:\n&amp;#34;, ++kase); scanf(&amp;#34;%d&amp;#34;, &amp;amp;k); while (k--) { scanf(&amp;#34;%s&amp;#34;, in); dfs(0, 1); } puts(&amp;#34;\n&amp;#34;); } return 0; }  è€ƒè™‘å˜é‡çš„é¡ºåº  #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>UVA672</title>
      <link>https://haofish.github.io/2020/uva672/</link>
      <pubDate>Sun, 02 Aug 2020 09:51:25 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva672/</guid>
      <description>Parentheses Balance #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int t; int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); getchar(); while (t--) { char str[150]; fgets(str, sizeof str, stdin); stack&amp;lt;char&amp;gt; st; for (int i = 0; str[i] != &amp;#39;\n&amp;#39;; i++) { if (str[i] == &amp;#39;)&amp;#39; &amp;amp;&amp;amp; st.size() &amp;amp;&amp;amp; st.top() == &amp;#39;(&amp;#39;) st.pop(); else if (str[i] == &amp;#39;]&amp;#39; &amp;amp;&amp;amp; st.size() &amp;amp;&amp;amp; st.top() == &amp;#39;[&amp;#39;) st.</description>
    </item>
    
    <item>
      <title>UVA572</title>
      <link>https://haofish.github.io/2020/uva572/</link>
      <pubDate>Fri, 31 Jul 2020 20:13:07 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva572/</guid>
      <description>Oil Deposits #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int m, n, cont[110][110]; char g[110][110]; void dfs(int x, int y, int num) { if (x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= m || y &amp;gt;= n || cont[x][y] || g[x][y] != &amp;#39;@&amp;#39;) return; cont[x][y] = num; for (int i = -1; i &amp;lt;= 1; i++) { for (int j = -1; j &amp;lt;= 1; j++) { if (i != 0 || j !</description>
    </item>
    
    <item>
      <title>UVA699</title>
      <link>https://haofish.github.io/2020/uva699/</link>
      <pubDate>Fri, 31 Jul 2020 19:38:47 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva699/</guid>
      <description>The Falling Leaves  æ‰€æœ‰æ•°æ®è¦ä»¥ç©ºè¡Œç›¸éš”ï¼ŒUVAç‰¹è‰²  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int M = 5e5; int node[M], t = 0; void build(int mid) { int v; scanf(&amp;#34;%d&amp;#34;, &amp;amp;v); if (v == -1) return; node[mid] += v; build(mid - 1); build(mid + 1); } bool read() { int v, mid = M &amp;gt;&amp;gt; 1; scanf(&amp;#34;%d&amp;#34;, &amp;amp;v); if (v == -1) return false; memset(node, 0, sizeof node); node[mid] = v; build(mid - 1); build(mid + 1); return true; } int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.</description>
    </item>
    
    <item>
      <title>UVA839</title>
      <link>https://haofish.github.io/2020/uva839/</link>
      <pubDate>Fri, 31 Jul 2020 17:53:32 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva839/</guid>
      <description>Not so Mobile #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int t, w; bool ok; void read(int &amp;amp;w) { int wl, dl, wr, dr; scanf(&amp;#34;%d%d%d%d&amp;#34;, &amp;amp;wl, &amp;amp;dl, &amp;amp;wr, &amp;amp;dr); if (wl == 0) read(wl); if (wr == 0) read(wr); w = wl + wr; if (wl * dl != wr * dr) ok = false; } int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); while (t--) { ok = true; read(w); if (ok) puts(&amp;#34;YES&amp;#34;); else puts(&amp;#34;NO&amp;#34;); if (t) puts(&amp;#34;&amp;#34;); } return 0; }  æ€»ç»“ï¼šè¿™é¢˜æ˜¯ä¸€ä¸ªå¾ˆç‰¹æ®Šçš„æ ‘ï¼Œåœ¨è¾“å…¥æ—¶å°±å¼€å§‹é€’å½’ï¼Œå€¼å¾—å­¦ä¹   </description>
    </item>
    
    <item>
      <title>UVA679</title>
      <link>https://haofish.github.io/2020/uva679/</link>
      <pubDate>Fri, 31 Jul 2020 11:53:31 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva679/</guid>
      <description>Dropping Balls #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int d, n, t; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); while (t--) { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;d, &amp;amp;n); int ans = 1; for (int i = 1; i &amp;lt; d; i++) { if (n &amp;amp; 1) { ans &amp;lt;&amp;lt;= 1; n = (n + 1) &amp;gt;&amp;gt; 1; } else { ans = ans &amp;lt;&amp;lt; 1 | 1; n &amp;gt;&amp;gt;= 1; } } printf(&amp;#34;%d\n&amp;#34;, ans); } return 0; } </description>
    </item>
    
    <item>
      <title>UVA548</title>
      <link>https://haofish.github.io/2020/uva548/</link>
      <pubDate>Fri, 31 Jul 2020 11:50:26 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva548/</guid>
      <description>Tree #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int M = 1e4 + 10; string str; int ino[M], posto[M], ans, Max, lson[M], rson[M], len = 0; void dfs(int u, int sum) { if (!lson[u] &amp;amp;&amp;amp; !rson[u]) { if (sum &amp;lt; Max || (sum == Max &amp;amp;&amp;amp; ans &amp;gt; u)) { ans = u, Max = sum; } } if (lson[u] != 0) dfs(lson[u], sum + lson[u]); if (rson[u] != 0) dfs(rson[u], sum + rson[u]); } int build(int a, int b, int c, int d) { if (c &amp;gt; d) return 0; int v = posto[b], indx = c; while (ino[indx] !</description>
    </item>
    
    <item>
      <title>UVA514</title>
      <link>https://haofish.github.io/2020/uva514/</link>
      <pubDate>Fri, 31 Jul 2020 11:48:14 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva514/</guid>
      <description>Rails #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; const int M = 1e3 + 10; int n, arr[M]; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;n), n) { while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;arr[1]), arr[1]) { for (int i = 2; i &amp;lt;= n; i++) { scanf(&amp;#34;%d&amp;#34;, arr + i); } stack&amp;lt;int&amp;gt; st; int in = 1, out = 1; bool ok = true; while (out &amp;lt;= n) { if (in == arr[out]) { in++, out++; } else if (st.</description>
    </item>
    
    <item>
      <title>UVA442</title>
      <link>https://haofish.github.io/2020/uva442/</link>
      <pubDate>Fri, 31 Jul 2020 11:44:20 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva442/</guid>
      <description>Matrix Chain Multiplication #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; using pii = pair&amp;lt;int, int&amp;gt;; int n; pii m[30]; char str[100000]; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 0; i &amp;lt; n; i++) { char a; int x, y; scanf(&amp;#34;\n%c%d%d&amp;#34;, &amp;amp;a, &amp;amp;x, &amp;amp;y); m[a - &amp;#39;A&amp;#39;] = make_pair(x, y); } getchar(); while (fgets(str, sizeof str, stdin)) { stack&amp;lt;pii&amp;gt; st; int len = strlen(str), ans = 0; if (str[len - 1] == &amp;#39;\n&amp;#39;) str[len-- - 1] = &amp;#39;\0&amp;#39;; bool ok = true; for (int i = 0; i &amp;lt; len; i++) { if (isalpha(str[i])) { st.</description>
    </item>
    
    <item>
      <title>UVA122</title>
      <link>https://haofish.github.io/2020/uva122/</link>
      <pubDate>Fri, 31 Jul 2020 11:19:07 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva122/</guid>
      <description>Trees on the level #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int M = 1e5 + 10; int lson[M], rson[M], cnt, node[M]; bool ok, in[M] = {false};//inè®°å½•èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ vector&amp;lt;int&amp;gt; ans; int newnode() {//ç”³è¯·æ–°çš„åœ°å€  int u = ++cnt; lson[u] = rson[u] = 0; return u; } void newtree() {//å»ºæ–°æ ‘  lson[1] = rson[1] = 0; in[1] = false; cnt = 1; } void build(int v, char *s) { int indx = 0, u = 1; while (s[indx] !</description>
    </item>
    
  </channel>
</rss>