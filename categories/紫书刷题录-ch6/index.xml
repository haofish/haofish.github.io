<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>紫书刷题录-ch6 on 🐟🐟🐟&lt;--</title>
    <link>https://haofish.github.io/categories/%E7%B4%AB%E4%B9%A6%E5%88%B7%E9%A2%98%E5%BD%95-ch6/</link>
    <description>Recent content in 紫书刷题录-ch6 on 🐟🐟🐟&lt;--</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 31 Jul 2020 20:13:07 +0800</lastBuildDate>
    
	<atom:link href="https://haofish.github.io/categories/%E7%B4%AB%E4%B9%A6%E5%88%B7%E9%A2%98%E5%BD%95-ch6/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>UVA572</title>
      <link>https://haofish.github.io/2020/uva572/</link>
      <pubDate>Fri, 31 Jul 2020 20:13:07 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva572/</guid>
      <description>Oil Deposits #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int m, n, cont[110][110]; char g[110][110]; void dfs(int x, int y, int num) { if (x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= m || y &amp;gt;= n || cont[x][y] || g[x][y] != &amp;#39;@&amp;#39;) return; cont[x][y] = num; for (int i = -1; i &amp;lt;= 1; i++) { for (int j = -1; j &amp;lt;= 1; j++) { if (i != 0 || j !</description>
    </item>
    
    <item>
      <title>UVA699</title>
      <link>https://haofish.github.io/2020/uva699/</link>
      <pubDate>Fri, 31 Jul 2020 19:38:47 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva699/</guid>
      <description>The Falling Leaves  所有数据要以空行相隔，UVA特色  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int M = 5e5; int node[M], t = 0; void build(int mid) { int v; scanf(&amp;#34;%d&amp;#34;, &amp;amp;v); if (v == -1) return; node[mid] += v; build(mid - 1); build(mid + 1); } bool read() { int v, mid = M &amp;gt;&amp;gt; 1; scanf(&amp;#34;%d&amp;#34;, &amp;amp;v); if (v == -1) return false; memset(node, 0, sizeof node); node[mid] = v; build(mid - 1); build(mid + 1); return true; } int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.</description>
    </item>
    
    <item>
      <title>UVA839</title>
      <link>https://haofish.github.io/2020/uva839/</link>
      <pubDate>Fri, 31 Jul 2020 17:53:32 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva839/</guid>
      <description>Not so Mobile #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int t, w; bool ok; void read(int &amp;amp;w) { int wl, dl, wr, dr; scanf(&amp;#34;%d%d%d%d&amp;#34;, &amp;amp;wl, &amp;amp;dl, &amp;amp;wr, &amp;amp;dr); if (wl == 0) read(wl); if (wr == 0) read(wr); w = wl + wr; if (wl * dl != wr * dr) ok = false; } int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); while (t--) { ok = true; read(w); if (ok) puts(&amp;#34;YES&amp;#34;); else puts(&amp;#34;NO&amp;#34;); if (t) puts(&amp;#34;&amp;#34;); } return 0; }  总结：这题是一个很特殊的树，在输入时就开始递归，值得学习  </description>
    </item>
    
    <item>
      <title>UVA679</title>
      <link>https://haofish.github.io/2020/uva679/</link>
      <pubDate>Fri, 31 Jul 2020 11:53:31 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva679/</guid>
      <description>Dropping Balls #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int d, n, t; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); while (t--) { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;d, &amp;amp;n); int ans = 1; for (int i = 1; i &amp;lt; d; i++) { if (n &amp;amp; 1) { ans &amp;lt;&amp;lt;= 1; n = (n + 1) &amp;gt;&amp;gt; 1; } else { ans = ans &amp;lt;&amp;lt; 1 | 1; n &amp;gt;&amp;gt;= 1; } } printf(&amp;#34;%d\n&amp;#34;, ans); } return 0; } </description>
    </item>
    
    <item>
      <title>UVA548</title>
      <link>https://haofish.github.io/2020/uva548/</link>
      <pubDate>Fri, 31 Jul 2020 11:50:26 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva548/</guid>
      <description>Tree #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int M = 1e4 + 10; string str; int ino[M], posto[M], ans, Max, lson[M], rson[M], len = 0; void dfs(int u, int sum) { if (!lson[u] &amp;amp;&amp;amp; !rson[u]) { if (sum &amp;lt; Max || (sum == Max &amp;amp;&amp;amp; ans &amp;gt; u)) { ans = u, Max = sum; } } if (lson[u] != 0) dfs(lson[u], sum + lson[u]); if (rson[u] != 0) dfs(rson[u], sum + rson[u]); } int build(int a, int b, int c, int d) { if (c &amp;gt; d) return 0; int v = posto[b], indx = c; while (ino[indx] !</description>
    </item>
    
    <item>
      <title>UVA514</title>
      <link>https://haofish.github.io/2020/uva514/</link>
      <pubDate>Fri, 31 Jul 2020 11:48:14 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva514/</guid>
      <description>Rails #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; const int M = 1e3 + 10; int n, arr[M]; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;n), n) { while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;arr[1]), arr[1]) { for (int i = 2; i &amp;lt;= n; i++) { scanf(&amp;#34;%d&amp;#34;, arr + i); } stack&amp;lt;int&amp;gt; st; int in = 1, out = 1; bool ok = true; while (out &amp;lt;= n) { if (in == arr[out]) { in++, out++; } else if (st.</description>
    </item>
    
    <item>
      <title>UVA442</title>
      <link>https://haofish.github.io/2020/uva442/</link>
      <pubDate>Fri, 31 Jul 2020 11:44:20 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva442/</guid>
      <description>Matrix Chain Multiplication #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; using pii = pair&amp;lt;int, int&amp;gt;; int n; pii m[30]; char str[100000]; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 0; i &amp;lt; n; i++) { char a; int x, y; scanf(&amp;#34;\n%c%d%d&amp;#34;, &amp;amp;a, &amp;amp;x, &amp;amp;y); m[a - &amp;#39;A&amp;#39;] = make_pair(x, y); } getchar(); while (fgets(str, sizeof str, stdin)) { stack&amp;lt;pii&amp;gt; st; int len = strlen(str), ans = 0; if (str[len - 1] == &amp;#39;\n&amp;#39;) str[len-- - 1] = &amp;#39;\0&amp;#39;; bool ok = true; for (int i = 0; i &amp;lt; len; i++) { if (isalpha(str[i])) { st.</description>
    </item>
    
    <item>
      <title>UVA122</title>
      <link>https://haofish.github.io/2020/uva122/</link>
      <pubDate>Fri, 31 Jul 2020 11:19:07 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva122/</guid>
      <description>Trees on the level #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int M = 1e5 + 10; int lson[M], rson[M], cnt, node[M]; bool ok, in[M] = {false};//in记录节点是否存在 vector&amp;lt;int&amp;gt; ans; int newnode() {//申请新的地址  int u = ++cnt; lson[u] = rson[u] = 0; return u; } void newtree() {//建新树  lson[1] = rson[1] = 0; in[1] = false; cnt = 1; } void build(int v, char *s) { int indx = 0, u = 1; while (s[indx] !</description>
    </item>
    
  </channel>
</rss>