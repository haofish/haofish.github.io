<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ç´«ä¹¦åˆ·é¢˜å½•-ch7 on ğŸŸğŸŸğŸŸ&lt;--</title>
    <link>https://haofish.github.io/categories/%E7%B4%AB%E4%B9%A6%E5%88%B7%E9%A2%98%E5%BD%95-ch7/</link>
    <description>Recent content in ç´«ä¹¦åˆ·é¢˜å½•-ch7 on ğŸŸğŸŸğŸŸ&lt;--</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 09 Aug 2020 20:37:14 +0800</lastBuildDate>
    
	<atom:link href="https://haofish.github.io/categories/%E7%B4%AB%E4%B9%A6%E5%88%B7%E9%A2%98%E5%BD%95-ch7/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>UVA10603</title>
      <link>https://haofish.github.io/2020/uva10603/</link>
      <pubDate>Sun, 09 Aug 2020 20:37:14 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva10603/</guid>
      <description>Fill  æŒ‰ç…§ä¹¦ä¸­çš„è¯´æ³•è¿™æ˜¯ä¸€ä¸ªéšå¼å›¾ï¼Œæ±‚æœ€çŸ­è·¯ï¼Œæœ€çŸ­è·¯çš„è¯„åˆ¤æ ‡å¿—æ˜¯å€’æ°´é‡  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;queue&amp;gt; using namespace std; const int M = 210; int cap[3], d, ans[M]; bool vis[M][M]; struct nodes{ int v[3], d; nodes(){} nodes(int v0, int v1, int v2, int d) :d(d) { v[0] = v0, v[1] = v1, v[2] = v2; } bool operator &amp;lt; (const nodes&amp;amp; tmp) const { return d &amp;gt; tmp.d; } }; void init() { memset(ans, -1, sizeof ans); memset(vis, 0, sizeof vis); } void update(nodes &amp;amp;u) { for (int i = 0; i &amp;lt; 3; i++) { if (ans[u.</description>
    </item>
    
    <item>
      <title>UVA1354</title>
      <link>https://haofish.github.io/2020/uva1354/</link>
      <pubDate>Sun, 09 Aug 2020 15:45:24 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva1354/</guid>
      <description>Mobile Computing  åšäº†ä¸¤å¤©ï¼Œä¹ å¾—äº†ä¸¤ç§dfséæšä¸¾å­é›†çš„åŠæ³•ï¼ˆåˆ°æ—¶å†å›å¤´ç ”ç©¶åˆ˜ç¥æ–¹æ³•ï¼‰ï¼Œåªé€‰æ‹©äº†ä¸€ç§å­¦ä¹ ï¼Œå½“ç„¶å¦ä¸€ç§ä¹Ÿçœ‹äº† è‡ªåº•å‘ä¸Šæšä¸¾äºŒå‰æ ‘ï¼Œæ€æƒ³æœ‰ç‚¹åƒå“ˆå¤«æ›¼å»ºæ ‘ï¼Œé€‰æ‹©ä¸¤ä¸ªèŠ‚ç‚¹æ¥åˆå¹¶ï¼Œç„¶åå°±æ˜¯é€’å½’å›æº¯çš„äº‹ dfs(n) ï¼šä»£è¡¨è¿˜å‰©ä¸‹ n ä¸ªèŠ‚ç‚¹å¯ä»¥æ‹¼æ¥ w[i] ï¼šä»£è¡¨ç¬¬ i ä¸ªèŠ‚ç‚¹çš„é‡é‡ï¼Œw[i] = 0 åˆ™è¡¨ç¤ºè¯¥èŠ‚ç‚¹å·²ç»è¢«ç”¨äº† l[i]ã€r[i] ï¼šä»£è¡¨ç¬¬ i èŠ‚ç‚¹çš„å·¦å³å®½åº¦çš„æœ€å¤§å€¼ å€¼å¾—æ³¨æ„çš„æ˜¯åœ¨æ±‚ l[i] å’Œ r[i] æ—¶åŒæ—¶è¦è€ƒè™‘å½“å‰å¦ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¾‹å¦‚åœ¨è®¡ç®— l[i] æ—¶ï¼Œä¸ä»…è¦è€ƒè™‘ å·¦å­æ ‘çš„å·¦æœ€å¤§å®½åº¦ + å½“å‰èŠ‚ç‚¹çš„å·¦å®½åº¦ï¼Œè¿˜è¦è€ƒè™‘ å³å­æ ‘çš„å·¦æœ€å¤§å®½åº¦ - å½“å‰èŠ‚ç‚¹çš„å³å®½åº¦ï¼Œå‰è€…å¾ˆå¥½ç†è§£ï¼Œå…³é”®æ˜¯åè€…ï¼šå› ä¸ºæœ‰å¯èƒ½å³å­æ ‘çš„å·¦æœ€å¤§å®½åº¦ä¼šè¶…è¿‡å·¦å­æ ‘ å…·ä½“çœ‹å›¾ï¼Œå³å­æ ‘åŒç†   æ˜¾ç„¶æ©™è‰²èŠ‚ç‚¹çš„è·ç¦»è¶…è¿‡äº†é»„è‰²èŠ‚ç‚¹ ä»£ç å¦‚ä¸‹  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; using vi = vector&amp;lt;int&amp;gt;; double d, Max, l[10], r[10]; int n, cnt, k = 0; vi w; void dfs(int num) { if (num == 1) { for (int i = 0; i &amp;lt; n; i++) { if (!</description>
    </item>
    
    <item>
      <title>UVA140</title>
      <link>https://haofish.github.io/2020/uva140/</link>
      <pubDate>Fri, 07 Aug 2020 19:53:14 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva140/</guid>
      <description>Bandwidth  æŒ‰ç…§ç´«ä¹¦çš„æŒ‡å¯¼ï¼Œå‰ªäº†ä¸¤ç§æï¼Œä½†æ˜¯æ„Ÿè§‰å‰ªä¸€ç§çš„é€Ÿåº¦å·®ä¸å¤šï¼Œä¸¤è€…äº¤ä¸Šå»éƒ½æ˜¯$0ms$ï¼Œæ¯•ç«ŸèŠ‚ç‚¹ä¸å¤šï¼Œå‰ªä¸€ç§æå°±è¡Œäº† ä»¥ä¸‹ä»£ç æ˜¯å‰ªäº†ä¸¤ç§æçš„ï¼Œå¦‚æœåªå‰ªä¸€ç§ï¼Œåªè¦æŠŠ28ï¼Œ60ï¼Œ62æ³¨é‡Šå°±è¡Œäº†  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; char str[200]; bool ext[26], ok[26][26]; int head[26], n, indx[26], vis[26], mind, con[26]; struct es{ int to, next; es(int to = 0, int next = -1) : to (to), next(next) {} }; vector&amp;lt;es&amp;gt; e; vector&amp;lt;char&amp;gt; node, res, ans; void add_edge(int u, int v) { e.push_back(es(v, head[u])); head[u] = e.size() - 1, con[u]++; if (!ext[u]) node.push_back(u + &amp;#39;A&amp;#39;); ext[u] = true; } bool check(int cur, int u) { if (!</description>
    </item>
    
    <item>
      <title>UVA129</title>
      <link>https://haofish.github.io/2020/uva129/</link>
      <pubDate>Fri, 07 Aug 2020 11:57:39 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva129/</guid>
      <description>Krypton Factor #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; int n, L, num = 0; bool ok = true; char ans[100], a[50], b[50]; bool check(int len) { if (!len) return false; for (int i = 1; i + i &amp;lt;= len + 1; i++) { memcpy(a, &amp;amp;ans[len - i + 1], sizeof(char) * i); memcpy(b, &amp;amp;ans[len - i - i + 1], sizeof(char) * i); a[i] = &amp;#39;\0&amp;#39;, b[i] = &amp;#39;\0&amp;#39;; if (strcmp(a, b) == 0) return true; } return false; } void dfs(int cur) { if (num &amp;gt; n) return; if (num == n) { size_t len = strlen(ans), s = 0, l = 0; for (size_t i = 0; i &amp;lt; len; i++) { if (s++ == 4) { if (l !</description>
    </item>
    
    <item>
      <title>UVA524</title>
      <link>https://haofish.github.io/2020/uva524/</link>
      <pubDate>Thu, 06 Aug 2020 20:32:38 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva524/</guid>
      <description>Prime Ring Problem #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; int kase = 0, n, arr[30]; bool isp[] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0}; bool vis[30]; void dfs(int cur, int *A) { if (cur == n - 1) { if (!</description>
    </item>
    
    <item>
      <title>UVA10976</title>
      <link>https://haofish.github.io/2020/uva10976/</link>
      <pubDate>Thu, 06 Aug 2020 18:27:25 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva10976/</guid>
      <description>Fractions Again?! #include &amp;lt;cstdio&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; using ll = long long; ll n; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (~scanf(&amp;#34;%lld&amp;#34;, &amp;amp;n)) { vector&amp;lt;ll&amp;gt; a, b; for (ll i = n + 1; i &amp;lt;= n + n; i++) { if (n * i % (i - n) == 0) { a.push_back(n * i / (i - n)); b.push_back(i); } } printf(&amp;#34;%zu\n&amp;#34;, a.</description>
    </item>
    
    <item>
      <title>UVA11059</title>
      <link>https://haofish.github.io/2020/uva11059/</link>
      <pubDate>Thu, 06 Aug 2020 17:34:18 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva11059/</guid>
      <description>Maximum Product #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; using ll = long long; int n, kase = 0; int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while(~scanf(&amp;#34;%d&amp;#34;, &amp;amp;n)) { ll Max = 0; vector&amp;lt;ll&amp;gt; arr(n); for (auto &amp;amp;x : arr) scanf(&amp;#34;%lld&amp;#34;, &amp;amp;x); for (int i = 0; i &amp;lt; n; i++) { ll tmp = arr[i]; Max = max(Max, tmp); for (int j = i + 1; j &amp;lt; n; j++) { tmp *= arr[j]; Max = max(Max, tmp); } } printf(&amp;#34;Case #%d: The maximum product is %lld.</description>
    </item>
    
    <item>
      <title>UVA725</title>
      <link>https://haofish.github.io/2020/uva725/</link>
      <pubDate>Thu, 06 Aug 2020 16:25:28 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva725/</guid>
      <description>Division #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; const int M = 1e5; int n; bool check(int a, int b) { bool num[10] = {0}; if (b &amp;lt; 10000) num[0] = true; while (a || b) { num[a % 10] = true; num[b % 10] = true; a /= 10, b /= 10; } int x = 0; for (auto i : num) if (i) x++; return x == 10; } bool check(int a) { bool num[10] = {0}; if (a &amp;lt; 10000) num[0] = true; while (a) { num[a % 10] = true; a /= 10; } int x = 0; for (auto i : num) if (i) x++; return x == 5; } int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.</description>
    </item>
    
  </channel>
</rss>