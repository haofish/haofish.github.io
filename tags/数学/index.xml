<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数学 on 🐟🐟🐟&lt;--</title>
    <link>https://haofish.github.io/tags/%E6%95%B0%E5%AD%A6/</link>
    <description>Recent content in 数学 on 🐟🐟🐟&lt;--</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 21 Sep 2020 17:31:50 +0800</lastBuildDate>
    
	<atom:link href="https://haofish.github.io/tags/%E6%95%B0%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>acm常用数学总结</title>
      <link>https://haofish.github.io/2020/acm%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 21 Sep 2020 17:31:50 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/acm%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/</guid>
      <description>前言  本博客主要记录和总结一些常用的数学数论知识 部分专业定义参考百度和其他大牛的博客  常见的基础名词 质数（素数）  对于一个大于1的自然数，当其的正因数（正约数）只有1和它本身时，则称该数为质数（素数） 注：1既不是质数也不是合数 有用的特性：  质数的因数是只有1和它本身 初等数学基本定理：任一大于1的自然数，要么本身是质数，要么可以分解为几个质数之积，且这种分解是唯一的 10以后的质数尾数都是1，3，7，9 质数的个数的无限的 对于$n(n &amp;gt; 0)$，$n^2$和$(n + 1)^2$之间至少有一个质数    完全数（完备数）  对于一个自然数，它等于它所有真因数的和（除他本身的正因数）则称它为完全数 例如：$6 = 1 + 2 + 3，28 = 1 + 2 + 4 + 7 + 14$  反素数 定理 算术基本定理  任何一个大于 1 的自然数可以分解成一些素数的乘积；并且在不计次序的情况下，这种分解方式是唯一的。——百度百科 内容：任何一个大于1的自然数N，如果N不为质数，则有  $$ N = {P_1}^{k_1} \times{P_2}^{k_2} \times {P_3}^{k_3} \cdots \times {P_n}^{k_n} \ \ , \ \ P_1 &amp;lt; P_2 &amp;lt; P_3 &amp;lt; \cdots &amp;lt; P_n $$</description>
    </item>
    
    <item>
      <title>C. A Cookie for You题解</title>
      <link>https://haofish.github.io/2020/654div2problemc/</link>
      <pubDate>Mon, 06 Jul 2020 20:28:19 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/654div2problemc/</guid>
      <description>传送门
题意  有 a 个 饼干，和 b 个巧克力 有 n 个 第一类人，有 m 个第二类人  对于第一类人， if (a &amp;gt; b)吃一个饼干，else 吃一个巧克力 对于第二类人， if (a &amp;gt; b)吃一个巧克力，else 吃一个饼干   问你是否有一种方法能让第一类和第二类人都有东西吃，有输出Yes，否则输出No  思考  很显然第一类人优先吃多的（一样多就吃巧克力），第二类人优先吃少的（一样多就吃饼干） 有两种思路，一个是我自己比赛时想到的，一个是x大佬讲的 方法一  一来就判断饼干和巧克力的总数够不够第一类和第二类人吃，如果不够，直接No，如果够如下 先让第二类人吃，方便我们思考，因为东西只会被越吃越少嘛，不可能越吃越多，所以他自始至终都会不会换别的吃 然后就是判断最少的是否够第二类人吃。先讨论最简单的——够，显然如果够的话则第一类人一定够吃，为什么，因为第一类人是优先吃最多的，而我们先判断的是总数都够吃，所以无论怎么吃，不管最多的东西怎么变化，都是够吃的,所以是Yes； 但是如果不够吃呢，直接就是No，为什么，解释起来有点麻烦（比赛时候我就是这里没有想好，一直往别的地方想，自己扰乱了自己的思维）。先这样想，如果不够吃，那么最小的永远都是那一个（饼干或者巧克力一开始最少的）：因为不够吃，所以那一个就会被吃完（即等于0），但是呢第二类人还有没吃到的，他们只会吃最少的那一个，而最少的那一个个数是0了，所以无论如何都吃不了了。 比赛的时候我往别的地方想了（相信不止我会这样想歪，现在想通了，解释一下，可能会有点啰嗦）：就是如果最少的不够第二类人吃的话那就一开始先让第一类人吃，或者中途到了某个关系后交替来吃。但是这样只会让自己陷入窘境，其实这种情况下，无论是让第一类人先吃，还是交替吃，都不会改变第二类人没得吃的结果。因为第一类人的插入只会让最多数量的那个东西变少，一直吃到饼干和巧克力个数一样时，最少的个数依然是最少，即便最少的种类可能会变，但是第二类人能吃的个数不会变。换句话说就是，即便它最少或最多的种类转移了，第二类依然会吃最少的，他不可能可以多吃一个多的那一个（即便饼干和巧克力相等） 详细见代码solve()函数   方法二  第一步和方法一相同，总数不够就No，否则如下 利用一个小规律：先让第二类人吃一次，再让第一类人吃一次，这样的话无论两者大小，饼干数和巧克力数都会各自减一。利用这个特点把人和东西给简化。 第一种可能，东西（饼干或者巧克力）优先有一方优先减到0，而两类人都还有，那么一定是No，因为第二类人只吃最少的，而最少的为0了 第二种可能就是，人优先有一方减到了0，这时候如果是第二类人减到了0，显然就是Yes（道理和方法一中最少数量的东西够第一类人吃是一样的）。如果是第一类人减到了0，那么也就是说只剩下第二类人，因为第二类人只吃最少的，所以只要判断最少的那个东西够不够第二类人吃就行了，够就Yes，不够就No 详细见代码solve2()函数   代码如下  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long ll; typedef vector&amp;lt;int&amp;gt; vi; typedef vector&amp;lt;long long&amp;gt; vll; typedef pair&amp;lt;int, int&amp;gt; pii; typedef pair&amp;lt;long long, long long&amp;gt; pll; #define debug printf(&amp;#34;(hao)&amp;#34;) #define all(x) x.</description>
    </item>
    
    <item>
      <title>D. Zero Remainder Array题解</title>
      <link>https://haofish.github.io/2020/653div3problemd/</link>
      <pubDate>Mon, 06 Jul 2020 16:58:31 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/653div3problemd/</guid>
      <description>传送门
题意  给你一个长度为 n 的数组$a_n$，和一个 k，你有一个 x（一开始为0），你有以下两种操作  给 x 加上 1，即$x = x + 1$ 选择一个任意一个$a_i$($0 \le i &amp;lt; n$)加上 x，然后 x 加上 1   每个元素最多只能被执行一次上诉操作 问你执行上述操作，x 最小为多少可以使得数组所有元素都能整除 k  思路  记录数组的每一个数至少要加多少才可以被 k 整除 寻找上述数中的最大的众数，计算 x 加到多少才可以使得这些数都能被 k 整除。 例如  对于一个数组 {1，1，1，2，3}，k = 6 则其至少要加的数为 {5，5，5，4，3} 显然最大的众数是 5，其个数是 3，那么对于第一个 5 则需要把 x 加到 5 就行了，对于第二个 5 ，就需要再等到下一个能模 6 为 5 的数，显然就是11($5 + 6 = 11$), 而第三个 5 也是同理就是 17，但这个还不是最终答案，因为题目的第二个操作是先给数组加上 x，再让 $x + 1$,所以最终答案就是 18   为什么这样就是对的呢？很简单，如果想要执行题中把所有数都弄成可以整除 k 并且每个数只能执行一次，对于两个相同且不能被 k 整除的数 y，想要把这两个 y 都弄成能被 k 整除，第二个数 y 一定要等到下一次有一个数 x 加上这个 y 使得它能整除 k。 所以我们要求出每个数最少加多少才可以被 k 整除，然后求一个最大的众数，计算最后一个众数需要的最小x（因为最后的 x 一定是停在了能使这些最大众数的最后一个数被 k 整除的结果），记得最后的答案要再加一才是最终答案。 那么其余的非最大众数呢？别担心，这些数在为最大众数服务的时候就能有一个 x 使得他们的一些能被 k 整除。例如上面的例子，我们在把 x 走到 5 的之前就有个4，可以使得数组中的 2 加上这个 4 能被 6 整除 还想不明白就想想模数具有周期性，例如将0 ~ n中的数都摸上 3 ，就会有这么一个规律 ：0 1 2 0 1 2 0 1 2 0 1 2····· 代码如下（求众数有点滑稽，因为我不会利用简单代码的求众数的方法）  #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>B. Multiply by 2, divide by 6题解</title>
      <link>https://haofish.github.io/2020/653div3problemb/</link>
      <pubDate>Mon, 06 Jul 2020 15:01:02 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/653div3problemb/</guid>
      <description>传送门
题意  给一个数 n,问你只进行以下两种操作，要操作最少多少次能够使得 n 为 1：  把 n 除以 6 （前提是可以整除） 把 n 乘 2   输出最少的操作次数，如果无论如何都没办法得到 1，则输出 -1  思路  首先要知道的是，如果对一个数同时进行两个操作就相当于对 n 除以 3 思考一个极端的例子就是：n 的质因子只有 3，那么它一定可以最终得到 1。为什么呢？因为我们可以让每个 3 都乘 2， 这样他就有了因子 6， 便可以做第一个操作了，并且最终得到 1 如果这个数既有 2 又有 3 怎么办？ 很简单，只需要把一对 2 和 3 看成 6，最终剩下的因子如果是 2（因为已经无望再去除以 6 了），则不可能得到 1，如果是 3， 则当成只有因子 3 的数看待（即上述的极端情况） 最后一种情况就是 n 的质因子除了 3 和 2 还有其他的质因子的话，一定最终无法得到 1 所以最终的想法就是：计算出质因子 2 的个数a，和计算出质因子 3 的个数 b, 如果 $a &amp;gt; b$ 则无法得到 1，否则要操作的次数最少为 $(b - a) \times 2 + a$ 代码如下  #include &amp;lt;bits/stdc++.</description>
    </item>
    
  </channel>
</rss>