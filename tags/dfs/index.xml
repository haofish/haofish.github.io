<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DFS on 🐟🐟🐟&lt;--</title>
    <link>https://haofish.github.io/tags/dfs/</link>
    <description>Recent content in DFS on 🐟🐟🐟&lt;--</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 11 Aug 2020 10:02:22 +0800</lastBuildDate>
    
	<atom:link href="https://haofish.github.io/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>UVA11212</title>
      <link>https://haofish.github.io/2020/uva11212/</link>
      <pubDate>Tue, 11 Aug 2020 10:02:22 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva11212/</guid>
      <description>Editing a Book  题意：给你一个排列，你一次能够剪切一段字串，然后在别的地方插入粘贴，让你求最少的剪切粘贴次数使得排列是1~n按顺序的 IDA*的题，每次规定递归的层数，长度为n的排列最多是剪切粘贴n - 1次 剪枝精髓：移动一次最多改变 3 个数字的后继数字，例如从{a，b，c，d}到{a, c, b, d},只有a, c, b（字母均代表区间）三个区间最后一个数的后继改变了 假设当前递归到d层，还有h个数字的后继不正确（最后一个数字的评判依据是是否是最后一个数，即$n - 1$），的最少还要遍历 $d + h / 3$ 层，当前设置了最大层数为Max, 则当 $d + h / 3 &amp;gt; Max$ 即 $3 \times d + h &amp;gt; 3 \times Max$ 就剪枝 代码如下，跑了300ms  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; int n, arr[15], tmp[15], kase = 0; bool check() { for (int i = 0; i &amp;lt; n; i++) { if (arr[i] !</description>
    </item>
    
    <item>
      <title>UVA1354</title>
      <link>https://haofish.github.io/2020/uva1354/</link>
      <pubDate>Sun, 09 Aug 2020 15:45:24 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva1354/</guid>
      <description>Mobile Computing  题意：有一个房间，有长为1的木棍，用天平的方式放一些物品，让你求出不超过房间的宽度的最长宽度的，如果误解输出-1 做了两天，习得了两种dfs非枚举子集的办法（到时再回头研究刘神方法），只选择了一种学习，当然另一种也看了 自底向上枚举二叉树，思想有点像哈夫曼建树，选择两个节点来合并，然后就是递归回溯的事 dfs(n) ：代表还剩下 n 个节点可以拼接 w[i] ：代表第 i 个节点的重量，w[i] = 0 则表示该节点已经被用了 l[i]、r[i] ：代表第 i 节点的左右宽度的最大值 值得注意的是在求 l[i] 和 r[i] 时同时要考虑当前另一个节点，例如在计算 l[i] 时，不仅要考虑 左子树的左最大宽度 + 当前节点的左宽度，还要考虑 右子树的左最大宽度 - 当前节点的右宽度，前者很好理解，关键是后者：因为有可能右子树的左最大宽度会超过左子树 具体看图，右子树同理   显然橙色节点的距离超过了黄色节点 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; using vi = vector&amp;lt;int&amp;gt;; double d, Max, l[10], r[10]; int n, cnt, k = 0; vi w; void dfs(int num) { if (num == 1) { for (int i = 0; i &amp;lt; n; i++) { if (!</description>
    </item>
    
    <item>
      <title>UVA140</title>
      <link>https://haofish.github.io/2020/uva140/</link>
      <pubDate>Fri, 07 Aug 2020 19:53:14 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva140/</guid>
      <description>Bandwidth  题意：给你一个无向图，让你输出一种序列使得每个节点到该节点在图中相连的节点的最远距离的最小值，直接看题目比较好懂 dfs遍历所有可能的序列，然后求出一个最小值，我的代码用了邻接表 剪枝的话一种是利用计算好最小带宽的一种来剪枝，第二种就是计算未确定位置的节点的最小带宽来剪 按照紫书的指导，剪了两种枝，但是感觉剪一种的速度差不多，两者交上去都是$0ms$，毕竟节点不多，剪一种枝就行了 以下代码是剪了两种枝的，如果只剪一种，只要把28，60，62注释就行了  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; char str[200]; bool ext[26], ok[26][26]; int head[26], n, indx[26], vis[26], mind, con[26]; struct es{ int to, next; es(int to = 0, int next = -1) : to (to), next(next) {} }; vector&amp;lt;es&amp;gt; e; vector&amp;lt;char&amp;gt; node, res, ans; void add_edge(int u, int v) { e.push_back(es(v, head[u])); head[u] = e.size() - 1, con[u]++; if (!ext[u]) node.push_back(u + &amp;#39;A&amp;#39;); ext[u] = true; } bool check(int cur, int u) { if (!</description>
    </item>
    
    <item>
      <title>UVA129</title>
      <link>https://haofish.github.io/2020/uva129/</link>
      <pubDate>Fri, 07 Aug 2020 11:57:39 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva129/</guid>
      <description>Krypton Factor  定义一个串是容易串：有相邻的相同的字串；反之就是困难串 让你求只利用前k个大写字母的第n个困难串 dfs模拟一下，值得注意的是剪枝时只看当前串的后缀即可，例如遍历到ABCDEFGH时，就只判断H和G、GH和EF、FGH和CDE、EFGH和ABCD就行了 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; int n, L, num = 0; bool ok = true; char ans[100], a[50], b[50]; bool check(int len) { if (!len) return false; for (int i = 1; i + i &amp;lt;= len + 1; i++) { memcpy(a, &amp;amp;ans[len - i + 1], sizeof(char) * i); memcpy(b, &amp;amp;ans[len - i - i + 1], sizeof(char) * i); a[i] = &amp;#39;\0&amp;#39;, b[i] = &amp;#39;\0&amp;#39;; if (strcmp(a, b) == 0) return true; } return false; } void dfs(int cur) { if (num &amp;gt; n) return; if (num == n) { size_t len = strlen(ans), s = 0, l = 0; for (size_t i = 0; i &amp;lt; len; i++) { if (s++ == 4) { if (l !</description>
    </item>
    
    <item>
      <title>UVA524</title>
      <link>https://haofish.github.io/2020/uva524/</link>
      <pubDate>Thu, 06 Aug 2020 20:32:38 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva524/</guid>
      <description>Prime Ring Problem  题意：给你一个数n，让你求出所有素数环，素数环：利用 1 ~ n来排列组合成的一个环，相邻的两个数的和必须都是素数 直接dfs遍历所有排列，途中要剪枝，如果当前放的数和前面的数的和不是素数就直接剪了 画出解答树更好懂 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; int kase = 0, n, arr[30]; bool isp[] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0}; bool vis[30]; void dfs(int cur, int *A) { if (cur == n - 1) { if (!</description>
    </item>
    
  </channel>
</rss>