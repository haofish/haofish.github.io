<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>动态规划 on 🐟🐟🐟&lt;--</title>
    <link>https://haofish.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
    <description>Recent content in 动态规划 on 🐟🐟🐟&lt;--</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Jul 2020 11:31:33 +0800</lastBuildDate>
    
	<atom:link href="https://haofish.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dp总结</title>
      <link>https://haofish.github.io/2020/dp%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 01 Jul 2020 11:31:33 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/dp%E6%80%BB%E7%BB%93/</guid>
      <description>[toc]
1. 写在前面的话  之前写了一篇不像总结的动态规划总结，感觉更像是一个成长历程，所以就打算重写一篇。  2. 对DP简单的总结   dp的题目特点
 求最大或者最小值（如背包：价值最大、凑硬币：数量最少……） 计数（如：爬楼梯：计算上到n台阶的方法数） 求存在性或者胜负（如：能否胜利……）    dp的使用条件
 拥有子问题 子问题最优解（即拥有最优子结构），对于一个主问题解最优，其子问题必定也是最优 问题结果依赖子问题，即问题的最优解依赖于其子问题的最优解 子问题不（或极少）重叠,即解决了暴力方法的重复计算和冗余问题 无后效性，即此时的之前状态无法直接影响未来的决策，换句话说就是之前的每个状态如何得来并不影响未来对此时（当前）状态的利用或者查找，因为我们最后对此时（当前）状态的利用只考虑结果不考虑过程。    dp的思考方式及注意事项
 若问题有dp的味道，应当优先从主问题出发来思考，即从末尾（结果）开始思考（例如爬楼梯问题） 接下来，对于一个主问题，应当思考此问题的结果由什么得来（由什么决定）和有什么因素影响 或者思考此问题类似什么DP题（如:背包、LIS……） 实在想不出可以思考如果是用bfs（或普通递归），应当如何解决问题（个人觉得有时候道理是相同的，记得吗：递归 + 记忆化 = 递推） 注意1：在思考一个状态的得来时，目光应当只集中在此时的状态（无后效性），而不要多想之前的状态变化和未来的状态影响 注意2：状态的定义很重要，要结合题目需求和状态影响因素来定义    关于dp三步走
 1.状态定义 → 2.列状态转移方程 → 3.验证方程 对于第一步和第二步主要可以利用上述的思考方式或者是闫氏DP分析法来解决 第三步虽然不难，但是很重要，因为第三步包括：验证状态推理是否合理或者是否是答案最优，并且思考状态是否满足题目条件需求，前者均没问题后再思考边界是什么。对于一般验证发现有问题通常的解决办法有：1、修改状态定义；2、给状态增加维度；3、优化转移方程    3. 几个重要的模型  例题静待补充
 4. 分类 ① 线性DP ② 区间DP ③ 树状DP 简介  所谓树状DP（树形DP）就是说一个动态规划的问题他的数据（或者子问题）之间是建立在树的基础上提问的，即父节点的最优是由其子节点的最优来推出来的（大部分是这样）。  【例题1】HDU 1520 Anniversary party   大致题意：一棵树，一共有n个节点，父节点和子节点不能同时选，每个节点都有权值，问怎么选权值总和最大</description>
    </item>
    
    <item>
      <title>动态规划刷题总结</title>
      <link>https://haofish.github.io/2020/dynamicprogramming/</link>
      <pubDate>Sat, 27 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://haofish.github.io/2020/dynamicprogramming/</guid>
      <description>[toc]
1、写在前面 这几天疯狂刷leetcode的dp题，刷到我都想吐了，看到一个题就先往dp想，感觉中毒不浅，话不多说，赶紧开始总结一下我的成长历程心得。
2、我对dp的看法和理解   首先引入《算法笔记》里的一句话:
 动态规划是一种非常精妙的算法思想，他没有固定的写法、极其灵活，常常需要具体问题具体分析。
 没错正式这种具体问题具体分析的设定让我刷到吐了
  平时在思考动态规划的往往是利用一个小小的公式：递推 = 递归 + 记忆化（下面会赘述我是怎么利用这个公式思考的）
  虽然他是这么说，但是我还是觉得dp的是有套路可循的，例如给dp分类 （背包dp、树形dp、区间dp……），经典题的记忆 （爬楼梯、树塔问题、LIS……）
  一般来说，我思考dp都是从结果往前想的（即从末尾开始想）
  dp的基本使用条件： 1. 拥有重叠子问题、 2. 最优子结构、3.无后效性
  dp思考三步走： 1. 状态定义 → 2.列状态转移方程 → 3.验证方程
  我觉得的动规成长路线：小白 → 利用小公式辅助建立dp → 正常dp三步走思维思考 → 大佬 （我还没触及 将来一定达到( ఠൠఠ )ﾉ）
  3、典型例题 ①爬楼梯（leetcode #70） 题意  假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。</description>
    </item>
    
  </channel>
</rss>