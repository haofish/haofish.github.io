<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BFS on ğŸŸğŸŸğŸŸ&lt;--</title>
    <link>https://haofish.github.io/tags/bfs/</link>
    <description>Recent content in BFS on ğŸŸğŸŸğŸŸ&lt;--</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 10 Aug 2020 17:00:48 +0800</lastBuildDate>
    
	<atom:link href="https://haofish.github.io/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>UVA1601</title>
      <link>https://haofish.github.io/2020/uva1601/</link>
      <pubDate>Mon, 10 Aug 2020 17:00:48 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva1601/</guid>
      <description>The Morning after Halloween  é¢˜æ„ï¼šç»™ä½ ä¸€ä¸ªå›¾ï¼Œ&amp;quot;#&amp;ldquo;ä¸ºéšœç¢ç‰©ï¼Œ&amp;rdquo; &amp;ldquo;ä¸ºé€šè·¯ï¼Œå›¾é‡Œé¢æœ€å¤šæœ‰3ä¸ªå°å†™å­—æ¯ï¼ˆa, b, cï¼‰å’Œäºå…¶å¯¹åº”çš„å¤§å†™å­—æ¯ï¼ˆA, B, Cï¼‰ï¼Œæ¯æ¬¡ç§»åŠ¨æ¯ä¸ªå°å†™å­—æ¯éƒ½æœ‰4ä¸ªæ–¹å‘å’Œä¸åŠ¨5ç§æ–¹æ¡ˆï¼Œä¸€æ¬¡ç§»åŠ¨å¯ä»¥æœ‰å¤šä¸ªå°å†™å­—æ¯ä¸€èµ·ç§»åŠ¨ï¼Œä¸èƒ½ä¸€ä¸ªç©ºæ ¼ç‚¹ä¸èƒ½åŒæ—¶æœ‰å¤šä¸ªå°å†™å­—æ¯ï¼Œé—®ä½ æœ€å°‘è¦ç§»åŠ¨å¤šå°‘æ¬¡æ‰èƒ½è®©è¿™äº›å°å†™å­—æ¯ç§»åŠ¨åˆ°å¯¹åº”çš„å¤§å†™å­—æ¯ä¸Š å—ç´«ä¹¦çš„å¯å‘ï¼Œäº†è§£åˆ°äº†ä¸€ä¸ªè§„çŸ©å›¾æˆ–è€…è¿·å®«äº¦æˆ–æ˜¯é¢˜ç›®ç»™çš„ä¸æ˜¯å›¾ï¼ˆä¾‹å¦‚ä¸Šæ¬¡çš„å€’æ°´é¢˜ï¼‰ï¼Œä¹Ÿèƒ½å¤Ÿåˆ©ç”¨â€œçŠ¶æ€â€æ¥ç®€åŒ–æˆä¸€ä¸ªå¹³æ—¶æˆ‘ä»¬æ›´å¤šçœ‹åˆ°çš„ç‚¹å¯¹ç‚¹çš„å›¾ï¼Œçœ‹æ¥æ˜¯å‡ ä¸ªèƒ½å¤Ÿç›¸äº’è¿æ¥äº§ç”Ÿå…³ç³»çš„çŠ¶æ€ï¼Œå°±èƒ½è€ƒè™‘åˆ©ç”¨çŠ¶æ€å›¾æ¥è§£ è¿™é¢˜çš„â€œçŠ¶æ€â€æ˜¯å¯¹æ¯ä¸ªåæ ‡çš„å‹ç¼©ï¼Œå‹ç¼©æˆä¸€ä¸ªä¸€ç»´çš„æ ‡å¿—ï¼Œçœ‹èµ·æ¥å°±å¥½åƒæ˜¯ç»™æ¯å®¶æ¯æˆ·ä¸Šä¸€ä¸ªé—¨ç‰Œå·ä¸€æ ·ï¼Œå› ä¸ºåæ ‡æœ€å¤§æ˜¯ï¼ˆ16, 16ï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´æœ€å¤šæœ‰256ä¸ªâ€œé—¨ç‰Œå·â€ï¼Œè¿™å¯¹äºä¸€ä¸ªå›¾æ¥è¯´è¿˜æ˜¯æœ‰ç‚¹å¤šï¼Œå¹¸è¿çš„æ˜¯é¢˜ä¸­è¯´æ¯ $2 \times 2$ çš„æ ¼å­è‡³å°‘æœ‰ä¸€ä¸ªå¯èµ°çš„ç‚¹ï¼Œè¿™æ ·æˆ‘ä»¬åªè¦è€ƒè™‘å¯ä»¥èµ°çš„ç‚¹å°±è¡Œäº† æŒ‰å‡ºç°é¡ºåºç»™å¯èµ°çš„ç‚¹ç¼–ä¸Šâ€œé—¨ç‰Œå·â€ï¼Œå¹¶è®°å½•ä¸Šå­—æ¯çš„é—¨ç‰Œå· è¿˜è¦è®°å½•æ¯ä¸ªç‚¹èƒ½åˆ°å“ªäº›ç‚¹ï¼Œè¿™æ ·å°±èƒ½å½“æˆä¸€ä¸ªæœ‰å‘å›¾æ¥çœ‹äº† å¦‚æœé¢˜ç›®ç»™çš„é¬¼çš„æ•°é‡ä¸åˆ°3ä¸ªï¼Œé‚£å¯ä»¥å‡è£…ä»–ç»™äº†ï¼Œä¸ºæ²¡ç»™çš„å­—æ¯å¼ºè¡ŒåŠ ä¸ªé—¨ç‰Œå·ï¼Œå¹¶ä¸”ä»–ä»¬å·²ç»åˆ°äº†è‡ªå·±çš„ç›®çš„åœ°ï¼Œå³ç›¸åº”çš„å¤§å°å†™å­—æ¯åœ¨åŒä¸€ä¸ªä½ç½® ä»¥ä¸‹ä»£ç æ˜¯å•å‘çš„BFS, vjä¸Šæµ‹å¾—æ˜¯930ms  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cctype&amp;gt; using namespace std; const int M = 210, f = 0xff; char g[M][M]; int w, n, h, s[3], t[3], id[20][20], dir[M][M][M]; const int dx[] = {-1, 0, 1, 0, 0}; const int dy[] = {0, -1, 0, 1, 0}; inline bool check(int x, int y) { return x &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt;= w &amp;amp;&amp;amp; y &amp;lt;= h; } inline int ID(int a, int b, int c) { return (a &amp;lt;&amp;lt; 16) | (b &amp;lt;&amp;lt; 8) | c; }//çŠ¶æ€å‹ç¼© inline bool move(int a, int b, int ago, int bgo) {//æ£€è½¦ç§»åŠ¨æ˜¯å¦åˆæ³•ï¼Œå³ä¸èƒ½ä¸€æ­¥äº¤æ¢ä½ç½®ï¼Œä¸èƒ½åˆ°åŒä¸€ä¸ªä½ç½®  return (a == bgo &amp;amp;&amp;amp; b == ago) || ago == bgo; } struct pos{ int x, y, n, go[5]; } p[200]; void BFS() { memset(dir, -1, sizeof dir); queue&amp;lt;int&amp;gt; q; q.</description>
    </item>
    
    <item>
      <title>UVA10603</title>
      <link>https://haofish.github.io/2020/uva10603/</link>
      <pubDate>Sun, 09 Aug 2020 20:37:14 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva10603/</guid>
      <description>Fill  é¢˜æ„ï¼šç»™ä½ 3ä¸ªæ²¡æœ‰åˆ»åº¦çš„æ¯å­ï¼Œæ¯ä¸ªæ¯å­çš„éƒ½æœ‰è‡ªå·±çš„å®¹é‡ï¼Œç°åˆ©ç”¨è¿™ä¸‰ä¸ªæ¯å­é‡å‡ºä½“ç§¯ä¸ºdçš„æ°´ï¼Œç°åœ¨é—®æœ€å°‘çš„å€’æ°´é‡ï¼Œå¦‚æœé‡ä¸åˆ°dï¼Œå°±é‡å’Œdæƒ³æ¥è¿‘çš„d&amp;rsquo; æŒ‰ç…§ä¹¦ä¸­çš„è¯´æ³•è¿™æ˜¯ä¸€ä¸ªéšå¼å›¾ï¼Œæ±‚æœ€çŸ­è·¯ï¼Œæœ€çŸ­è·¯çš„è¯„åˆ¤æ ‡å¿—æ˜¯å€’æ°´é‡  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;queue&amp;gt; using namespace std; const int M = 210; int cap[3], d, ans[M]; bool vis[M][M]; struct nodes{ int v[3], d; nodes(){} nodes(int v0, int v1, int v2, int d) :d(d) { v[0] = v0, v[1] = v1, v[2] = v2; } bool operator &amp;lt; (const nodes&amp;amp; tmp) const { return d &amp;gt; tmp.d; } }; void init() { memset(ans, -1, sizeof ans); memset(vis, 0, sizeof vis); } void update(nodes &amp;amp;u) { for (int i = 0; i &amp;lt; 3; i++) { if (ans[u.</description>
    </item>
    
  </channel>
</rss>