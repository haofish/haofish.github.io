<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 🐟🐟🐟&lt;--</title>
    <link>https://haofish.github.io/posts/</link>
    <description>Recent content in Posts on 🐟🐟🐟&lt;--</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 11 Aug 2020 10:02:22 +0800</lastBuildDate>
    
	<atom:link href="https://haofish.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>UVA11212</title>
      <link>https://haofish.github.io/2020/uva11212/</link>
      <pubDate>Tue, 11 Aug 2020 10:02:22 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva11212/</guid>
      <description>Editing a Book  题意：给你一个排列，你一次能够剪切一段字串，然后在别的地方插入粘贴，让你求最少的剪切粘贴次数使得排列是1~n按顺序的 IDA*的题，每次规定递归的层数，长度为n的排列最多是剪切粘贴n - 1次 剪枝精髓：移动一次最多改变 3 个数字的后继数字，例如从{a，b，c，d}到{a, c, b, d},只有a, c, b（字母均代表区间）三个区间最后一个数的后继改变了 假设当前递归到d层，还有h个数字的后继不正确（最后一个数字的评判依据是是否是最后一个数，即$n - 1$），的最少还要遍历 $d + h / 3$ 层，当前设置了最大层数为Max, 则当 $d + h / 3 &amp;gt; Max$ 即 $3 \times d + h &amp;gt; 3 \times Max$ 就剪枝 代码如下，跑了300ms  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; int n, arr[15], tmp[15], kase = 0; bool check() { for (int i = 0; i &amp;lt; n; i++) { if (arr[i] !</description>
    </item>
    
    <item>
      <title>UVA1601</title>
      <link>https://haofish.github.io/2020/uva1601/</link>
      <pubDate>Mon, 10 Aug 2020 17:00:48 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva1601/</guid>
      <description>The Morning after Halloween  题意：给你一个图，&amp;quot;#&amp;ldquo;为障碍物，&amp;rdquo; &amp;ldquo;为通路，图里面最多有3个小写字母（a, b, c）和于其对应的大写字母（A, B, C），每次移动每个小写字母都有4个方向和不动5种方案，一次移动可以有多个小写字母一起移动，不能一个空格点不能同时有多个小写字母，问你最少要移动多少次才能让这些小写字母移动到对应的大写字母上 受紫书的启发，了解到了一个规矩图或者迷宫亦或是题目给的不是图（例如上次的倒水题），也能够利用“状态”来简化成一个平时我们更多看到的点对点的图，看来是几个能够相互连接产生关系的状态，就能考虑利用状态图来解 这题的“状态”是对每个坐标的压缩，压缩成一个一维的标志，看起来就好像是给每家每户上一个门牌号一样，因为坐标最大是（16, 16），也就是说最多有256个“门牌号”，这对于一个图来说还是有点多，幸运的是题中说每 $2 \times 2$ 的格子至少有一个可走的点，这样我们只要考虑可以走的点就行了 按出现顺序给可走的点编上“门牌号”，并记录上字母的门牌号 还要记录每个点能到哪些点，这样就能当成一个有向图来看了 如果题目给的鬼的数量不到3个，那可以假装他给了，为没给的字母强行加个门牌号，并且他们已经到了自己的目的地，即相应的大小写字母在同一个位置 以下代码是单向的BFS, vj上测得是930ms  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cctype&amp;gt; using namespace std; const int M = 210, f = 0xff; char g[M][M]; int w, n, h, s[3], t[3], id[20][20], dir[M][M][M]; const int dx[] = {-1, 0, 1, 0, 0}; const int dy[] = {0, -1, 0, 1, 0}; inline bool check(int x, int y) { return x &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt;= w &amp;amp;&amp;amp; y &amp;lt;= h; } inline int ID(int a, int b, int c) { return (a &amp;lt;&amp;lt; 16) | (b &amp;lt;&amp;lt; 8) | c; }//状态压缩 inline bool move(int a, int b, int ago, int bgo) {//检车移动是否合法，即不能一步交换位置，不能到同一个位置  return (a == bgo &amp;amp;&amp;amp; b == ago) || ago == bgo; } struct pos{ int x, y, n, go[5]; } p[200]; void BFS() { memset(dir, -1, sizeof dir); queue&amp;lt;int&amp;gt; q; q.</description>
    </item>
    
    <item>
      <title>UVA10603</title>
      <link>https://haofish.github.io/2020/uva10603/</link>
      <pubDate>Sun, 09 Aug 2020 20:37:14 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva10603/</guid>
      <description>Fill  题意：给你3个没有刻度的杯子，每个杯子的都有自己的容量，现利用这三个杯子量出体积为d的水，现在问最少的倒水量，如果量不到d，就量和d想接近的d&amp;rsquo; 按照书中的说法这是一个隐式图，求最短路，最短路的评判标志是倒水量  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;queue&amp;gt; using namespace std; const int M = 210; int cap[3], d, ans[M]; bool vis[M][M]; struct nodes{ int v[3], d; nodes(){} nodes(int v0, int v1, int v2, int d) :d(d) { v[0] = v0, v[1] = v1, v[2] = v2; } bool operator &amp;lt; (const nodes&amp;amp; tmp) const { return d &amp;gt; tmp.d; } }; void init() { memset(ans, -1, sizeof ans); memset(vis, 0, sizeof vis); } void update(nodes &amp;amp;u) { for (int i = 0; i &amp;lt; 3; i++) { if (ans[u.</description>
    </item>
    
    <item>
      <title>UVA1354</title>
      <link>https://haofish.github.io/2020/uva1354/</link>
      <pubDate>Sun, 09 Aug 2020 15:45:24 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva1354/</guid>
      <description>Mobile Computing  题意：有一个房间，有长为1的木棍，用天平的方式放一些物品，让你求出不超过房间的宽度的最长宽度的，如果误解输出-1 做了两天，习得了两种dfs非枚举子集的办法（到时再回头研究刘神方法），只选择了一种学习，当然另一种也看了 自底向上枚举二叉树，思想有点像哈夫曼建树，选择两个节点来合并，然后就是递归回溯的事 dfs(n) ：代表还剩下 n 个节点可以拼接 w[i] ：代表第 i 个节点的重量，w[i] = 0 则表示该节点已经被用了 l[i]、r[i] ：代表第 i 节点的左右宽度的最大值 值得注意的是在求 l[i] 和 r[i] 时同时要考虑当前另一个节点，例如在计算 l[i] 时，不仅要考虑 左子树的左最大宽度 + 当前节点的左宽度，还要考虑 右子树的左最大宽度 - 当前节点的右宽度，前者很好理解，关键是后者：因为有可能右子树的左最大宽度会超过左子树 具体看图，右子树同理   显然橙色节点的距离超过了黄色节点 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; using vi = vector&amp;lt;int&amp;gt;; double d, Max, l[10], r[10]; int n, cnt, k = 0; vi w; void dfs(int num) { if (num == 1) { for (int i = 0; i &amp;lt; n; i++) { if (!</description>
    </item>
    
    <item>
      <title>UVA140</title>
      <link>https://haofish.github.io/2020/uva140/</link>
      <pubDate>Fri, 07 Aug 2020 19:53:14 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva140/</guid>
      <description>Bandwidth  题意：给你一个无向图，让你输出一种序列使得每个节点到该节点在图中相连的节点的最远距离的最小值，直接看题目比较好懂 dfs遍历所有可能的序列，然后求出一个最小值，我的代码用了邻接表 剪枝的话一种是利用计算好最小带宽的一种来剪枝，第二种就是计算未确定位置的节点的最小带宽来剪 按照紫书的指导，剪了两种枝，但是感觉剪一种的速度差不多，两者交上去都是$0ms$，毕竟节点不多，剪一种枝就行了 以下代码是剪了两种枝的，如果只剪一种，只要把28，60，62注释就行了  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; char str[200]; bool ext[26], ok[26][26]; int head[26], n, indx[26], vis[26], mind, con[26]; struct es{ int to, next; es(int to = 0, int next = -1) : to (to), next(next) {} }; vector&amp;lt;es&amp;gt; e; vector&amp;lt;char&amp;gt; node, res, ans; void add_edge(int u, int v) { e.push_back(es(v, head[u])); head[u] = e.size() - 1, con[u]++; if (!ext[u]) node.push_back(u + &amp;#39;A&amp;#39;); ext[u] = true; } bool check(int cur, int u) { if (!</description>
    </item>
    
    <item>
      <title>UVA129</title>
      <link>https://haofish.github.io/2020/uva129/</link>
      <pubDate>Fri, 07 Aug 2020 11:57:39 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva129/</guid>
      <description>Krypton Factor  定义一个串是容易串：有相邻的相同的字串；反之就是困难串 让你求只利用前k个大写字母的第n个困难串 dfs模拟一下，值得注意的是剪枝时只看当前串的后缀即可，例如遍历到ABCDEFGH时，就只判断H和G、GH和EF、FGH和CDE、EFGH和ABCD就行了 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; int n, L, num = 0; bool ok = true; char ans[100], a[50], b[50]; bool check(int len) { if (!len) return false; for (int i = 1; i + i &amp;lt;= len + 1; i++) { memcpy(a, &amp;amp;ans[len - i + 1], sizeof(char) * i); memcpy(b, &amp;amp;ans[len - i - i + 1], sizeof(char) * i); a[i] = &amp;#39;\0&amp;#39;, b[i] = &amp;#39;\0&amp;#39;; if (strcmp(a, b) == 0) return true; } return false; } void dfs(int cur) { if (num &amp;gt; n) return; if (num == n) { size_t len = strlen(ans), s = 0, l = 0; for (size_t i = 0; i &amp;lt; len; i++) { if (s++ == 4) { if (l !</description>
    </item>
    
    <item>
      <title>UVA524</title>
      <link>https://haofish.github.io/2020/uva524/</link>
      <pubDate>Thu, 06 Aug 2020 20:32:38 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva524/</guid>
      <description>Prime Ring Problem  题意：给你一个数n，让你求出所有素数环，素数环：利用 1 ~ n来排列组合成的一个环，相邻的两个数的和必须都是素数 直接dfs遍历所有排列，途中要剪枝，如果当前放的数和前面的数的和不是素数就直接剪了 画出解答树更好懂 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; int kase = 0, n, arr[30]; bool isp[] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0}; bool vis[30]; void dfs(int cur, int *A) { if (cur == n - 1) { if (!</description>
    </item>
    
    <item>
      <title>UVA10976</title>
      <link>https://haofish.github.io/2020/uva10976/</link>
      <pubDate>Thu, 06 Aug 2020 18:27:25 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva10976/</guid>
      <description>Fractions Again?! #include &amp;lt;cstdio&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; using ll = long long; ll n; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (~scanf(&amp;#34;%lld&amp;#34;, &amp;amp;n)) { vector&amp;lt;ll&amp;gt; a, b; for (ll i = n + 1; i &amp;lt;= n + n; i++) { if (n * i % (i - n) == 0) { a.push_back(n * i / (i - n)); b.push_back(i); } } printf(&amp;#34;%zu\n&amp;#34;, a.</description>
    </item>
    
    <item>
      <title>UVA11059</title>
      <link>https://haofish.github.io/2020/uva11059/</link>
      <pubDate>Thu, 06 Aug 2020 17:34:18 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva11059/</guid>
      <description>Maximum Product  给你一个数组，让你求子字串的最大乘积，如果没有就输出0 暴力解就好了  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; using ll = long long; int n, kase = 0; int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while(~scanf(&amp;#34;%d&amp;#34;, &amp;amp;n)) { ll Max = 0; vector&amp;lt;ll&amp;gt; arr(n); for (auto &amp;amp;x : arr) scanf(&amp;#34;%lld&amp;#34;, &amp;amp;x); for (int i = 0; i &amp;lt; n; i++) { ll tmp = arr[i]; Max = max(Max, tmp); for (int j = i + 1; j &amp;lt; n; j++) { tmp *= arr[j]; Max = max(Max, tmp); } } printf(&amp;#34;Case #%d: The maximum product is %lld.</description>
    </item>
    
    <item>
      <title>UVA725</title>
      <link>https://haofish.github.io/2020/uva725/</link>
      <pubDate>Thu, 06 Aug 2020 16:25:28 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva725/</guid>
      <description>Division  题意：给你一个数n，让你求出 $abcde / fghij = n$ 的所有结果，a ~ j 的恰好是 0 ~ 9 的数 暴力遍历分子就好了，然后检查分母是否合法就行了  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; const int M = 1e5; int n; bool check(int a, int b) { bool num[10] = {0}; if (b &amp;lt; 10000) num[0] = true; while (a || b) { num[a % 10] = true; num[b % 10] = true; a /= 10, b /= 10; } int x = 0; for (auto i : num) if (i) x++; return x == 10; } bool check(int a) { bool num[10] = {0}; if (a &amp;lt; 10000) num[0] = true; while (a) { num[a % 10] = true; a /= 10; } int x = 0; for (auto i : num) if (i) x++; return x == 5; } int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.</description>
    </item>
    
    <item>
      <title>UVA10410</title>
      <link>https://haofish.github.io/2020/uva10410/</link>
      <pubDate>Wed, 05 Aug 2020 10:12:16 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva10410/</guid>
      <description>Tree Reconstruction  题意：给你一个DFS和一个BFS遍历的树（具体遍历方式都是小的权值优先），让你求出每个节点的子节点 直接说思路：栈的运用，题目说输出任意可能的答案，所以把树当成一个二叉树来做，bfs本质就是树的一层一层的遍历，当一个节点在bfs序中下标为 $x$，则 $x + 1$可以认为是他的兄弟节点，其后面的都是下层的节点；而dfs的本质是一个链式的深度搜索，也就是说dfs中连续的很可能就是树的一条链式。根据以上性质，用栈来模拟dfs的建造过程，再更具上诉bfs的性质来判断某节点是否是栈顶的一个子节点 代码如下  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int n, x; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  for (; ~scanf(&amp;#34;%d&amp;#34;, &amp;amp;n);) { vector&amp;lt;int&amp;gt; node[1010], dfs(n), bfs(n + 1); for (int i = 1; i &amp;lt;= n; i++) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); bfs[x] = i; } for (auto &amp;amp;i : dfs) scanf(&amp;#34;%d&amp;#34;, &amp;amp;i); stack&amp;lt;int&amp;gt; st; int root = dfs[0]; st.</description>
    </item>
    
    <item>
      <title>UVA806</title>
      <link>https://haofish.github.io/2020/uva806/</link>
      <pubDate>Tue, 04 Aug 2020 18:02:01 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva806/</guid>
      <description>Spatial Structures  类似于计算像素的，读懂题意直接模拟就好了 毒瘤题  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; using ll = long long; int n, kase = 0; char g[70][70], m[70][70]; vector&amp;lt;ll&amp;gt; ans; void dfs(int r1, int c1, int r2, int c2, ll all, int d, int pos) { if (r1 == r2) { if (m[r1][c1] == &amp;#39;1&amp;#39;) ans.push_back(all + pos * pow(5, d - 1)); return; } int sum1 = 0, sum2 = 0, sum3 = 0, sum4 = 0; for (int i = r1; i &amp;lt;= (r2 + r1) / 2; i++) { for (int j = c1; j &amp;lt;= (c2 + c1) / 2; j++) { sum1 += m[i][j] - &amp;#39;0&amp;#39;; } } for (int i = r1; i &amp;lt;= (r2 + r1) / 2; i++) { for (int j = (c1 + c2) / 2 + 1; j &amp;lt;= c2; j++) { sum2 += m[i][j] - &amp;#39;0&amp;#39;; } } for (int i = (r1 + r2) / 2 + 1; i &amp;lt;= r2; i++) { for (int j = c1; j &amp;lt;= (c1 + c2) / 2; j++) { sum3 += m[i][j] - &amp;#39;0&amp;#39;; } } for (int i = (r1 + r2) / 2 + 1; i &amp;lt;= r2; i++) { for (int j = (c1 + c2) / 2 + 1; j &amp;lt;= c2; j++) { sum4 += m[i][j] - &amp;#39;0&amp;#39;; } } int sum = sum1 + sum2 + sum3 + sum4; ll x = 0; if (d) x = all + pos*pow(5, d - 1); if (sum == (r2 - r1 + 1) * (c2 - c1 + 1)) { if (x) ans.</description>
    </item>
    
    <item>
      <title>UVA804</title>
      <link>https://haofish.github.io/2020/uva804/</link>
      <pubDate>Tue, 04 Aug 2020 14:26:40 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva804/</guid>
      <description>Petri Net Simulation  每个T变迁都有限制，必须是指定的P库有足够的token才行（注意，T指定的P库不一定只有一个），直接模拟就好了  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int p[110], np, nt, kase = 0; struct T { int in[110], out[110]; T() { memset(in, 0, sizeof in); memset(out, 0, sizeof out); } }; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  for (; scanf(&amp;#34;%d&amp;#34;, &amp;amp;np), np;) { for (int i = 1; i &amp;lt;= np; i++) { scanf(&amp;#34;%d&amp;#34;, p + i); } scanf(&amp;#34;%d&amp;#34;, &amp;amp;nt); int x; T ts[110]; for (int i = 1; i &amp;lt;= nt; i++) { for (; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x), x;) { if (x &amp;lt; 0) ts[i].</description>
    </item>
    
    <item>
      <title>UVA12166</title>
      <link>https://haofish.github.io/2020/uva12166/</link>
      <pubDate>Mon, 03 Aug 2020 20:27:46 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva12166/</guid>
      <description>Equilibrium Mobile  题意：给你一个天平，修改某些节点可以使得天平平衡，让你求出最小的修改数量 竟然是一道思维题，不行，这题要写写题解 思路：  假设这个数是一个满二叉树的，并且每个叶子节点每个叶子节点的重量（权值）都不一样，则最少的修改次数就是：叶子节点数 - 1，具体策略就是找一个叶子节点为基准点，设其重量为$x$，然后把其余的叶子节点的重量都修改成$x$，设数的深度为$h$，则此时整棵树的的重量为 $x \times 2 ^ {h - 1}$ 对于其他情况，我们可以根据上述的特殊情况来推导，假设以某个叶子节点为基准点，然后计算修改后整棵树的重量（根据公式 $x \times 2 ^ {h - 1}$） 所以策略就是，计算每个叶子节点以其为基准点修改后的整棵树的重量，这样计算下去，可能会出现计算结果相同的情况，就意味着以该叶子节点为基准点修改时，有不需要修改的叶子节点 那么我们就可以统计以每个叶子节点为基准点修改后的整棵树的重量的值，出现最多次数的就说明以该叶子节点为基准点修改，有最多的叶子节点不需要修改，固需要修改的叶子节点个数最少 剩下的就是代码实现了，由于重量可能很大，固用哈希来存放该重量的数量   代码如下  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; using ll = long long; int t, num; char str[1000005]; unordered_map&amp;lt;ll, int&amp;gt; myhash; void dfs(int l, int r, ll d) { if (str[l] == &amp;#39;[&amp;#39;) { int l_indx = l + 1, p = 0; while (l_indx &amp;lt; r) { if (str[l_indx] == &amp;#39;[&amp;#39;) p++; if (str[l_indx] == &amp;#39;]&amp;#39;) p--; if (p == 0) break; l_indx++; } int r_indx = strchr(&amp;amp;str[l_indx], &amp;#39;,&amp;#39;) - &amp;amp;str[l_indx] + l_indx; dfs(l + 1, l_indx, d + 1); dfs(r_indx + 1, r - 1, d + 1); return; } ll w = 0; sscanf(&amp;amp;str[l], &amp;#34;%lld&amp;#34;, &amp;amp;w); myhash[w * (1 &amp;lt;&amp;lt; d)]++; num++; } int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.</description>
    </item>
    
    <item>
      <title>UVA1600</title>
      <link>https://haofish.github.io/2020/uva1600/</link>
      <pubDate>Mon, 03 Aug 2020 16:26:13 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva1600/</guid>
      <description>Patrol Robot  BFS进阶题 题意：有个移动的机器人，从（1， 1）点出发，目标是（m， n）点，0为可以通过的点，1为障碍点，机器人一次最多只能穿越k障碍，问你最少要走多少步到达终点 BFS走，要注意个是要记录到达障碍点的最短穿越障碍个数  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int n, m, g[25][25], t, k; const int dx[] = {-1, 0, 1, 0}; const int dy[] = {0, -1, 0, 1}; inline bool check(int x, int y) { return x &amp;gt;= 1 &amp;amp;&amp;amp; y &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n &amp;amp;&amp;amp; y &amp;lt;= m; } struct coo{ int x, y, d, k; coo(){} coo(int x, int y, int d, int k) : x(x), y(y), d(d), k(k){} }; void bfs() { queue&amp;lt;coo&amp;gt; q; bool vis[25][25][25] = {0}; vis[1][1][0] = g[1][1] == 1; q.</description>
    </item>
    
    <item>
      <title>UVA439</title>
      <link>https://haofish.github.io/2020/uva439/</link>
      <pubDate>Sun, 02 Aug 2020 16:15:00 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva439/</guid>
      <description>Knight Moves  题意：在象棋里，给马的起点和终点，计算最小移动步数  #include &amp;lt;bits/stdc++.h&amp;gt;#define mk(a, b) make_pair(a, b) using namespace std; using pii = pair&amp;lt;int, int&amp;gt;; using pdi = pair&amp;lt;pii, int&amp;gt;; int sx, sy, ex, ey; bool vis[10][10]; char a[5], b[5]; const int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2}; const int dy[] = {-1, -2, -2, -1, 1, 2, 2, 1}; inline bool cherk(int x, int y) { return x &amp;gt; 0 &amp;amp;&amp;amp; y &amp;gt; 0 &amp;amp;&amp;amp; x &amp;lt; 9 &amp;amp;&amp;amp; y &amp;lt; 9; } void print(int num) { printf(&amp;#34;To get from %s to %s takes %d knight moves.</description>
    </item>
    
    <item>
      <title>UVA536</title>
      <link>https://haofish.github.io/2020/uva536/</link>
      <pubDate>Sun, 02 Aug 2020 15:35:18 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva536/</guid>
      <description>Tree Recovery  给你一个二叉树的先序和中序遍历，输出对应的后序遍历  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; char pre[30], in[30]; void dfs(int a, int b, int c, int d) { if (c &amp;gt; d) return; char tmp = pre[a]; int indx = c; while (in[indx] != tmp) indx++; dfs(a + 1, a + indx - c, c, indx - 1); dfs(a + indx - c + 1, b, indx + 1, d); printf(&amp;#34;%c&amp;#34;, tmp); } int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.</description>
    </item>
    
    <item>
      <title>UVA712</title>
      <link>https://haofish.github.io/2020/uva712/</link>
      <pubDate>Sun, 02 Aug 2020 14:41:02 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva712/</guid>
      <description>S-Trees  题意：一棵二叉树，每个层节点都有有个逻辑布尔变量，0往左走，1往右走，给你最后一层的结果值，再给你每个变量的取值，问你最后走到的最后一层叶子节点的值 这题有点迷，一开始忘记记录变量的顺序尽然也过了，后来记录了也能过 不考虑变量的顺序  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int n, k, kase = 0;; char res[600], in[10]; void dfs(int indx, int x) { if (indx == n) { printf(&amp;#34;%c&amp;#34;, res[x - (1 &amp;lt;&amp;lt; n)]); return; } if (in[indx] == &amp;#39;0&amp;#39;) dfs(indx + 1, x &amp;lt;&amp;lt; 1); else dfs(indx + 1, x &amp;lt;&amp;lt; 1 | 1); } int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;n), n) { char tmp[10]; for (int i = 0; i &amp;lt; n; i++) { scanf(&amp;#34;%s&amp;#34;, tmp); } scanf(&amp;#34;%s&amp;#34;, res); printf(&amp;#34;S-Tree #%d:\n&amp;#34;, ++kase); scanf(&amp;#34;%d&amp;#34;, &amp;amp;k); while (k--) { scanf(&amp;#34;%s&amp;#34;, in); dfs(0, 1); } puts(&amp;#34;\n&amp;#34;); } return 0; }  考虑变量的顺序  #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>UVA672</title>
      <link>https://haofish.github.io/2020/uva672/</link>
      <pubDate>Sun, 02 Aug 2020 09:51:25 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva672/</guid>
      <description>Parentheses Balance  让你判断括号是否合法，栈的经典例题  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int t; int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); getchar(); while (t--) { char str[150]; fgets(str, sizeof str, stdin); stack&amp;lt;char&amp;gt; st; for (int i = 0; str[i] != &amp;#39;\n&amp;#39;; i++) { if (str[i] == &amp;#39;)&amp;#39; &amp;amp;&amp;amp; st.size() &amp;amp;&amp;amp; st.top() == &amp;#39;(&amp;#39;) st.pop(); else if (str[i] == &amp;#39;]&amp;#39; &amp;amp;&amp;amp; st.size() &amp;amp;&amp;amp; st.</description>
    </item>
    
    <item>
      <title>UVA816</title>
      <link>https://haofish.github.io/2020/uva816/</link>
      <pubDate>Sat, 01 Aug 2020 15:56:21 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva816/</guid>
      <description>Abbott&amp;rsquo;s Revenge  题意：给你起点和终点，每个点面向不同的方向有不用的指定方向，问你从起点到终点最短路 BFS就好，但是要注意的是每个点都有不用的方向，所以要多加一维来保存这些方向，即每个点相当于是4个点 一道值得学习深究的一题  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const char dis[] = &amp;#34;NESW&amp;#34;, go[] = &amp;#34;RLF&amp;#34;; const int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, 1, 0, -1 }; int sx, sy, rx, ry, ex, ey, rd, d[15][15][4]; bool ok[15][15][4][3]; inline int get_dis(char c) { return strchr(dis, c) - dis; } inline int get_go(char c) { return strchr(go, c) - go; } inline bool cherk(int x, int y) { return x &amp;gt; 0 &amp;amp;&amp;amp; x &amp;lt;= 9 &amp;amp;&amp;amp; y &amp;gt; 0 &amp;amp;&amp;amp; y &amp;lt;= 9; } struct nodes{ int x, y, d; nodes(int x = 0, int y = 0, int d = 0) : x(x), y(y), d(d) {} }pre[15][15][4]; nodes work(nodes &amp;amp;node, int i) { int dr = node.</description>
    </item>
    
    <item>
      <title>UVA10305</title>
      <link>https://haofish.github.io/2020/uva10305/</link>
      <pubDate>Sat, 01 Aug 2020 09:47:35 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva10305/</guid>
      <description>Ordering Tasks  题意：给你一堆未知数的大小关系，让你输出可能的总体大小关系 简化了拓扑排序，只因根据题中的意思了解到一定是DAG  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int M = 110; int m, n, vis[M]; bool g[M][M]; vector&amp;lt;int&amp;gt; ans; void dfs(int u) { vis[u] = true; for (int i = 1; i &amp;lt;= m; i++) { if (!vis[i] &amp;amp;&amp;amp; g[u][i]) { dfs(i); } } ans.push_back(u); } int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;m, &amp;amp;n), m + n) { int x, y; for (int i = 0; i &amp;lt; n; i++) { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;x, &amp;amp;y); g[x][y] = true; } for (int i = 1; i &amp;lt;= m; i++) { if (vis[i]) continue; dfs(i); } reverse(ans.</description>
    </item>
    
    <item>
      <title>UVA572</title>
      <link>https://haofish.github.io/2020/uva572/</link>
      <pubDate>Fri, 31 Jul 2020 20:13:07 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva572/</guid>
      <description>Oil Deposits  给你一个矩形图，让你求连通的“@”块，一个连通的定义是该点的八个方向都是连通的，dfs就行了  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int m, n, cont[110][110]; char g[110][110]; void dfs(int x, int y, int num) { if (x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= m || y &amp;gt;= n || cont[x][y] || g[x][y] != &amp;#39;@&amp;#39;) return; cont[x][y] = num; for (int i = -1; i &amp;lt;= 1; i++) { for (int j = -1; j &amp;lt;= 1; j++) { if (i !</description>
    </item>
    
    <item>
      <title>UVA699</title>
      <link>https://haofish.github.io/2020/uva699/</link>
      <pubDate>Fri, 31 Jul 2020 19:38:47 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva699/</guid>
      <description>The Falling Leaves  二叉树的计算，直接递归读入遍历即可 所有数据要以空行相隔，UVA特色  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int M = 5e5; int node[M], t = 0; void build(int mid) { int v; scanf(&amp;#34;%d&amp;#34;, &amp;amp;v); if (v == -1) return; node[mid] += v; build(mid - 1); build(mid + 1); } bool read() { int v, mid = M &amp;gt;&amp;gt; 1; scanf(&amp;#34;%d&amp;#34;, &amp;amp;v); if (v == -1) return false; memset(node, 0, sizeof node); node[mid] = v; build(mid - 1); build(mid + 1); return true; } int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.</description>
    </item>
    
    <item>
      <title>UVA839</title>
      <link>https://haofish.github.io/2020/uva839/</link>
      <pubDate>Fri, 31 Jul 2020 17:53:32 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva839/</guid>
      <description>Not so Mobile  题意：天平平衡，题意很好懂，就是让你判断给的天平平不平衡，直接递归读入就好了  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int t, w; bool ok; void read(int &amp;amp;w) { int wl, dl, wr, dr; scanf(&amp;#34;%d%d%d%d&amp;#34;, &amp;amp;wl, &amp;amp;dl, &amp;amp;wr, &amp;amp;dr); if (wl == 0) read(wl); if (wr == 0) read(wr); w = wl + wr; if (wl * dl != wr * dr) ok = false; } int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); while (t--) { ok = true; read(w); if (ok) puts(&amp;#34;YES&amp;#34;); else puts(&amp;#34;NO&amp;#34;); if (t) puts(&amp;#34;&amp;#34;); } return 0; }  总结：这题是一个很特殊的树，在输入时就开始递归，值得学习  </description>
    </item>
    
    <item>
      <title>UVA679</title>
      <link>https://haofish.github.io/2020/uva679/</link>
      <pubDate>Fri, 31 Jul 2020 11:53:31 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva679/</guid>
      <description>Dropping Balls  题意：小球在一个二叉树上下落，每个节点都有一个开关，起初全是关的，如果节点是开小球往右走，反之往左走，让你求最后一个球落到了哪个节点 如果直接单纯的模拟是会超时的，观察可以发现一个节点的第奇数个球都会落到左子树，第偶数个球都落到了右边，自己草稿模拟一下就好了 代码如下  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int d, n, t; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); while (t--) { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;d, &amp;amp;n); int ans = 1; for (int i = 1; i &amp;lt; d; i++) { if (n &amp;amp; 1) { ans &amp;lt;&amp;lt;= 1; n = (n + 1) &amp;gt;&amp;gt; 1; } else { ans = ans &amp;lt;&amp;lt; 1 | 1; n &amp;gt;&amp;gt;= 1; } } printf(&amp;#34;%d\n&amp;#34;, ans); } return 0; } </description>
    </item>
    
    <item>
      <title>UVA548</title>
      <link>https://haofish.github.io/2020/uva548/</link>
      <pubDate>Fri, 31 Jul 2020 11:50:26 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva548/</guid>
      <description>Tree  给你二叉树的中序和先序遍历，让你求从根节点到叶节点的的距离权值和最小，如果有多解，叶节点的权值要小，输出叶节点的权值  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int M = 1e4 + 10; string str; int ino[M], posto[M], ans, Max, lson[M], rson[M], len = 0; void dfs(int u, int sum) { if (!lson[u] &amp;amp;&amp;amp; !rson[u]) { if (sum &amp;lt; Max || (sum == Max &amp;amp;&amp;amp; ans &amp;gt; u)) { ans = u, Max = sum; } } if (lson[u] != 0) dfs(lson[u], sum + lson[u]); if (rson[u] !</description>
    </item>
    
    <item>
      <title>UVA514</title>
      <link>https://haofish.github.io/2020/uva514/</link>
      <pubDate>Fri, 31 Jul 2020 11:48:14 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva514/</guid>
      <description>Rails  让你判断列车出站是否正确，栈的运用  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; const int M = 1e3 + 10; int n, arr[M]; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;n), n) { while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;arr[1]), arr[1]) { for (int i = 2; i &amp;lt;= n; i++) { scanf(&amp;#34;%d&amp;#34;, arr + i); } stack&amp;lt;int&amp;gt; st; int in = 1, out = 1; bool ok = true; while (out &amp;lt;= n) { if (in == arr[out]) { in++, out++; } else if (st.</description>
    </item>
    
    <item>
      <title>UVA442</title>
      <link>https://haofish.github.io/2020/uva442/</link>
      <pubDate>Fri, 31 Jul 2020 11:44:20 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva442/</guid>
      <description>Matrix Chain Multiplication  矩阵链乘，栈的运用  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; using pii = pair&amp;lt;int, int&amp;gt;; int n; pii m[30]; char str[100000]; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 0; i &amp;lt; n; i++) { char a; int x, y; scanf(&amp;#34;\n%c%d%d&amp;#34;, &amp;amp;a, &amp;amp;x, &amp;amp;y); m[a - &amp;#39;A&amp;#39;] = make_pair(x, y); } getchar(); while (fgets(str, sizeof str, stdin)) { stack&amp;lt;pii&amp;gt; st; int len = strlen(str), ans = 0; if (str[len - 1] == &amp;#39;\n&amp;#39;) str[len-- - 1] = &amp;#39;\0&amp;#39;; bool ok = true; for (int i = 0; i &amp;lt; len; i++) { if (isalpha(str[i])) { st.</description>
    </item>
    
    <item>
      <title>UVA122</title>
      <link>https://haofish.github.io/2020/uva122/</link>
      <pubDate>Fri, 31 Jul 2020 11:19:07 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva122/</guid>
      <description>Trees on the level  二叉树的建立  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int M = 1e5 + 10; int lson[M], rson[M], cnt, node[M]; bool ok, in[M] = {false};//in记录节点是否存在 vector&amp;lt;int&amp;gt; ans; int newnode() {//申请新的地址  int u = ++cnt; lson[u] = rson[u] = 0; return u; } void newtree() {//建新树  lson[1] = rson[1] = 0; in[1] = false; cnt = 1; } void build(int v, char *s) { int indx = 0, u = 1; while (s[indx] !</description>
    </item>
    
    <item>
      <title>贪心刷题总结</title>
      <link>https://haofish.github.io/2020/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 25 Jul 2020 19:08:51 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>前言 总结 普通贪心 区间贪心 未完待续……  前言  终于开始刷贪心了，感觉cf很多题都喜欢出贪心，所以决定也练练 贪心貌似也有挺系统的分类和一些经典例题，把这些刷了应该就有提升了把  总结  贪心是指将问题通过当前最优解来求解得到最终的最优解，即局部最优解可以推出总体最优解。 给我的感觉就是一种思维题，通过一定技巧把题目旁敲侧击地解决了，但是如果没接触过或者想不出来，基本就很难了，但是贪心的代码实现并不长，所以说贪心即使很基础的算法也是很难的算法。 总得来说贪心算法难就难在每道题的贪心策略都不同，是否能贪心也很难看出来。 一般在解决贪心题的时候可以把他放到生活中的例子来，想想如果是生活中碰到这题，你会怎么解决让自己最舒服。  普通贪心   【例题】
  HDU 2111 Saving HDU
 题意：你有可以装k个宝贝容量的包，现在给你一些宝贝，每个宝贝价值p，有m个，问你最多可以装多少价值的宝贝 思路：将价值排序，先选大的，选到v = 0为止 代码如下  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;utility&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; int n, v; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;v), v) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; for (int i = 0; i &amp;lt; n; i++) { int p, m; scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;p, &amp;amp;m); q.</description>
    </item>
    
    <item>
      <title>Olympiad</title>
      <link>https://haofish.github.io/2020/olympiad/</link>
      <pubDate>Fri, 24 Jul 2020 19:25:00 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/olympiad/</guid>
      <description>传送门  题意：给你两个同长数组代表n个人两场比赛的成绩，再给你一个x，某两个数组的和$a_i + b_j \ge x$，问你两数组组合成满足式子的排名最高和最低是多少。具体看样例就懂了。 思路：此题对于最高排名一定是1，即第一名，而最低排名的话，一开始知道是一个双指针的贪心，但是就是不知道怎么贪，后来看到大佬的想法豁然开朗：只要找到组合后大于等于x的个数有多少就好了。 具体找法：一个数组a大到小排序，一个数组b小到大排序，然后只要从a从头开始一个一个遍历，从b数组中从头找能与a数组的数加起来大于等于x的数就好了，然后记录个数，就是答案 心得：贪心题目是难想，想到之后就很简单，代码量也不大，还有一个比较考验的就是模拟的功力了（从人的思维去想想如果这不是一道编程题，而是一个生活的益智题，你会怎么做？然后再用代码实现,说的简单，感觉还是要多刷题） 代码如下  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt; using namespace std; const int M = 1e5 + 5; int n, x, a[M], b[M]; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;x); for (int i = 0; i &amp;lt; n; i++) { scanf(&amp;#34;%d&amp;#34;, a + i); } for (int i = 0; i &amp;lt; n; i++) { scanf(&amp;#34;%d&amp;#34;, b + i); } printf(&amp;#34;1 &amp;#34;); sort(a, a + n); sort(b, b + n); reverse(a, a + n); //a从大到小排序  int j = 0, ans = 0; for (int i = 0; i &amp;lt; n; i++) { while (j &amp;lt; n &amp;amp;&amp;amp; b[j] + a[i] &amp;lt; x) { j++; } if (j &amp;gt;= n) break; ans++; j++; } printf(&amp;#34;%d&amp;#34;, ans); return 0; } </description>
    </item>
    
    <item>
      <title>Cosmic_Tables</title>
      <link>https://haofish.github.io/2020/cosmic_tables/</link>
      <pubDate>Fri, 24 Jul 2020 16:26:14 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/cosmic_tables/</guid>
      <description>传送门  题意：给你一个矩阵，每次进行与行之间的交换，或者是列与列之间的交换，或者查询(x, y)点的值 思路：一开始想着是不是直接就纯模拟算了，后来想想，直接用数组把行和列也记录下来不就好了吗 代码如下  #include &amp;lt;cstdio&amp;gt; using namespace std; const int M = 1e3 + 10; int r[M], c[M], g[M][M], n, m, k; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;n, &amp;amp;m, &amp;amp;k); for (int i = 1; i &amp;lt;= n; i++) r[i] = i; for (int i = 1; i &amp;lt;= m; i++) c[i] = i; for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= m; j++) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;g[i][j]); } } while (k--) { char a; int x, y; scanf(&amp;#34;\n%c %d %d&amp;#34;, &amp;amp;a, &amp;amp;x, &amp;amp;y); if (a == &amp;#39;r&amp;#39;) {//交换操作  r[x] ^= r[y], r[y] ^= r[x], r[x] ^= r[y]; } else if (a == &amp;#39;c&amp;#39;) { c[x] ^= c[y], c[y] ^= c[x], c[x] ^= c[y]; } else { printf(&amp;#34;%d\n&amp;#34;, g[r[x]][c[y]]); } } return 0; } </description>
    </item>
    
    <item>
      <title>Shooshuns_and_Sequence</title>
      <link>https://haofish.github.io/2020/shooshuns_and_sequence/</link>
      <pubDate>Fri, 24 Jul 2020 15:15:22 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/shooshuns_and_sequence/</guid>
      <description>传送门  什么鬼，div2也出水题？还是我变强了？😂 题意：给你一个长为n的序列，再给你一个k，你每次都必须要这样做：选择第k个数，把他复制到序列的最后，再把序列的第一个数给删了，问你要操作多少次可以使得序列数组的数全部相同，如果根本不可能通过上述操作使得序列数组的数全部相同，则输出-1 思路：不难发现，如果一开始第k个数及后面的数有出现不同的数的话，是不可能通过上述操作使得整个数组完全相同，如果可能的话，就往k前找，即往左找，找到第一个与第k个数不同的数，输出他的下标就好了（因为要一直删到那个不同的数），模拟一下就好了。 代码如下  #include &amp;lt;cstdio&amp;gt; using namespace std; const int M = 1e5 + 10; int n, k, arr[M]; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;k); for (int i = 0; i &amp;lt; n; i++) { scanf(&amp;#34;%d&amp;#34;, arr + i); } int tmp = arr[k - 1]; for (int i = k; i &amp;lt; n; i++) { if (arr[i] !</description>
    </item>
    
    <item>
      <title>Tourist&#39;s_Notes</title>
      <link>https://haofish.github.io/2020/tourists_notes/</link>
      <pubDate>Fri, 24 Jul 2020 09:56:16 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/tourists_notes/</guid>
      <description>传送门  题意：旅行者每天都会记录自己的海拔高度，他每天规定走海拔相差不超过1的路线，有一天他的记录丢失了，只剩下几天的，问你他之前有可能到达的最高海拔是多少，如果数据出现矛盾，输出&amp;quot;IMPOSSIBLE&amp;rdquo; 思路：用两个数组记录天数和当天的海拔高度，如果相隔的海拔差比相隔的天数差还大的话就是矛盾，否则就这样计算相隔天数中可能的最大海拔高度：$MaxHight = ( day[i] + hight[i] - (day[i - 1] - hight[i - 1]) ) / 2$，最后取众多MaxHight的最大值 注意：第一天和最后一天的数据可能没给，所以我们要自己造一个可能的最大高度，例如只给你第3天的海拔高度为5，总共旅行的天数为4，那么我们就自己造一个第一天的高度为7$(5 + 3 - 1)$，第4天的高度为6$(5 + (4 - 3))$，就是一开始没想到这个，wa了2发/(ㄒoㄒ)/~~ 代码如下：  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; const int M = 1e5 + 10; int n, m, d[M], h[M]; bool ok = true; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); for (int i = 1; i &amp;lt;= m; i++) { scanf(&amp;#34;%d%d&amp;#34;, d + i, h + i); if (i !</description>
    </item>
    
    <item>
      <title>Quasi_Binary</title>
      <link>https://haofish.github.io/2020/quasi_binary/</link>
      <pubDate>Thu, 23 Jul 2020 21:08:02 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/quasi_binary/</guid>
      <description>传送门  题意：一个只由1和0组成的十进制数叫做Quasi Binary，例如11（十一）就是，现在给你一个n，让你求出他可能有哪些Quasi Binary的和组成，输出最少的Quasi Binary个数并将他们输出 思路：模拟，用个二维数组记录所有的结果位数结果，然后相加输出。例如32就是记录10、10、10、1、1，然后分别将不同位数的相加得到11（10 + 1），11（10 + 1），10（10 + 0） 代码如下  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); int t = n, sum = 0; while (t) { sum = max(t % 10, sum); t /= 10; } printf(&amp;#34;%d\n&amp;#34;, sum); int tmp, x = 0, y = 0, numset[7][10] = {0}, w = 1; while (n) { tmp = n % 10, y = 0; while (tmp) { numset[x][y++] = w; tmp--; } n /= 10, x++, w *= 10; } for (int i = 0; i &amp;lt; sum; i++) { int res = 0; for (int j = 0; j &amp;lt; 7; j++) { res += numset[j][i]; } printf(&amp;#34;%d &amp;#34;, res); } return 0; } </description>
    </item>
    
    <item>
      <title>Cutting_Banner</title>
      <link>https://haofish.github.io/2020/cutting_banner/</link>
      <pubDate>Thu, 23 Jul 2020 20:08:59 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/cutting_banner/</guid>
      <description>传送门  题意：给你个字符串，减去一段子串，是否能将剩下的不改变顺序拼成&amp;quot;CODEFORCES&amp;rdquo;，能则输出&amp;quot;YES&amp;rdquo;，否则输出&amp;quot;NO&amp;rdquo; 思路：直接枚举减去的长度，然后暴力 代码如下  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; char aim[] = &amp;#34;CODEFORCES&amp;#34;, str[200], tmp[200]; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%s&amp;#34;, str); if (strcmp(str, aim) == 0) { puts(&amp;#34;YES&amp;#34;); return 0; } int len = strlen(str); for (int i = 1; i &amp;lt;= len; i++) { for (int j = 0; j + i - 1 &amp;lt; len; j++) { int ind = 0; for (int k = 0; k &amp;lt; len; k++) { if (k &amp;lt; j || k &amp;gt; j + i - 1) { tmp[ind++] = str[k]; } } tmp[ind] = &amp;#39;\0&amp;#39;; if (strcmp(tmp, aim) == 0) { puts(&amp;#34;YES&amp;#34;); return 0; } } } puts(&amp;#34;NO&amp;#34;); return 0; } </description>
    </item>
    
    <item>
      <title>图论刷题总结</title>
      <link>https://haofish.github.io/2020/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 21 Jul 2020 22:22:01 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>前言 总结 最短路  Dijkstra Bellman-Ford Floyd Spfa   未完待续  前言  起因是一次力扣周赛时被一道最短论的题给整蒙了，决定这几天恶补图论，正好POJ的刷题题单刷到了图 打算学习图论从零开始，目前刷的题不多  总结  关于存图  不同的存图方式可以使得不同的算法更加方便，例如：邻接表可以使Dijkstra算法在堆优化中方便不少，而邻接矩阵可以使Floyd算法更加方便   关于建图  有一些题目在描述的时候给的数据不好建图，这需要经验的积累 而有一些题目并没有直接说明是图，换句话说能否看出是使用图论的知识来解题也需要经验的累积   关于计算  题目中的要求并不是一成不变的，有时候最短路径并不是仅仅指的是值最短，有时候也有可能题目让你求最大值，但最短路依然可以解    最短路  先从最短路开始刷，刷到后面发现有些题三个算法（Dijkstra、Bellman-Ford、Floyd）都是可以解的  Dijkstra   [例题]
  洛谷P4779 【模板】单源最短路径（标准版）
 题意：最短路板子题，不解释 思路：直接用Dijkstra的堆优化做，因为没有负环 直接上代码  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;locale&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;utility&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef long long ll; typedef pair&amp;lt;int, int&amp;gt; pii; const int M = 2e5 + 10; const ll INF = 0x3f3f3f3f; int n, m, s, cnt = 0; struct edges { int w, to, next; edges(int a = 0, int b = 0, int c = -1) : w(b), to(a), next(c) {} }; vector&amp;lt;int&amp;gt; head, dis; vector&amp;lt;edges&amp;gt; edge; inline void add(int u, int v, int w) { edge[++cnt] = edges(v, w, head[u]); head[u] = cnt; } void dij() { vector&amp;lt;bool&amp;gt; vis(n + 1, false); dis = vector&amp;lt;int&amp;gt;(n + 1, INF); priority_queue&amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt; heap; dis[s] = 0; heap.</description>
    </item>
    
    <item>
      <title>模板</title>
      <link>https://haofish.github.io/2020/%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Mon, 13 Jul 2020 17:12:35 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/%E6%A8%A1%E6%9D%BF/</guid>
      <description>基础  二分 快速幂 最大公因数，最小公倍数 素数筛（埃式） 高精（不压位） 高精（压位） 离散化 未完待续……   数据结构  树状数组 线段树 dijkstra(堆优化版) bellman - ford floyd    基础 二分    二分分法：[l, mid) 和 [mid, r],目标值符合右区间及其端点    int bsearch(int l, int r){ while (l &amp;lt; r) { int mid = (long long)(l + r) &amp;gt;&amp;gt; 1;//相当于 l + r 后向下取整  if (/* 探针落在左区间 */) l = mid + 1; else r = mid; } return l; }   二分分法：[l, mid] 和 (mid, r], 目标值符合左区间及其端点    int bsearch(int l, int r){ while (l &amp;lt; r) { int mid = (long long)(l + r + 1) &amp;gt;&amp;gt; 1; //相当于 l + r 后向上取整，否则陷入死循环，例如 此时 l = 1, r = 2, 那么探针就会一直落到左区间 l 上（l + r &amp;gt;&amp;gt; 1 = 1），下一步 l = mid = l,就会死循环  if (/* 探针落在左区间 */) l = mid; else r = mid - 1; } return l; } 二分参考资料</description>
    </item>
    
    <item>
      <title>C. A Cookie for You题解</title>
      <link>https://haofish.github.io/2020/654div2problemc/</link>
      <pubDate>Mon, 06 Jul 2020 20:28:19 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/654div2problemc/</guid>
      <description>传送门
题意  有 a 个 饼干，和 b 个巧克力 有 n 个 第一类人，有 m 个第二类人  对于第一类人， if (a &amp;gt; b)吃一个饼干，else 吃一个巧克力 对于第二类人， if (a &amp;gt; b)吃一个巧克力，else 吃一个饼干   问你是否有一种方法能让第一类和第二类人都有东西吃，有输出Yes，否则输出No  思考  很显然第一类人优先吃多的（一样多就吃巧克力），第二类人优先吃少的（一样多就吃饼干） 有两种思路，一个是我自己比赛时想到的，一个是x大佬讲的 方法一  一来就判断饼干和巧克力的总数够不够第一类和第二类人吃，如果不够，直接No，如果够如下 先让第二类人吃，方便我们思考，因为东西只会被越吃越少嘛，不可能越吃越多，所以他自始至终都会不会换别的吃 然后就是判断最少的是否够第二类人吃。先讨论最简单的——够，显然如果够的话则第一类人一定够吃，为什么，因为第一类人是优先吃最多的，而我们先判断的是总数都够吃，所以无论怎么吃，不管最多的东西怎么变化，都是够吃的,所以是Yes； 但是如果不够吃呢，直接就是No，为什么，解释起来有点麻烦（比赛时候我就是这里没有想好，一直往别的地方想，自己扰乱了自己的思维）。先这样想，如果不够吃，那么最小的永远都是那一个（饼干或者巧克力一开始最少的）：因为不够吃，所以那一个就会被吃完（即等于0），但是呢第二类人还有没吃到的，他们只会吃最少的那一个，而最少的那一个个数是0了，所以无论如何都吃不了了。 比赛的时候我往别的地方想了（相信不止我会这样想歪，现在想通了，解释一下，可能会有点啰嗦）：就是如果最少的不够第二类人吃的话那就一开始先让第一类人吃，或者中途到了某个关系后交替来吃。但是这样只会让自己陷入窘境，其实这种情况下，无论是让第一类人先吃，还是交替吃，都不会改变第二类人没得吃的结果。因为第一类人的插入只会让最多数量的那个东西变少，一直吃到饼干和巧克力个数一样时，最少的个数依然是最少，即便最少的种类可能会变，但是第二类人能吃的个数不会变。换句话说就是，即便它最少或最多的种类转移了，第二类依然会吃最少的，他不可能可以多吃一个多的那一个（即便饼干和巧克力相等） 详细见代码solve()函数   方法二  第一步和方法一相同，总数不够就No，否则如下 利用一个小规律：先让第二类人吃一次，再让第一类人吃一次，这样的话无论两者大小，饼干数和巧克力数都会各自减一。利用这个特点把人和东西给简化。 第一种可能，东西（饼干或者巧克力）优先有一方优先减到0，而两类人都还有，那么一定是No，因为第二类人只吃最少的，而最少的为0了 第二种可能就是，人优先有一方减到了0，这时候如果是第二类人减到了0，显然就是Yes（道理和方法一中最少数量的东西够第一类人吃是一样的）。如果是第一类人减到了0，那么也就是说只剩下第二类人，因为第二类人只吃最少的，所以只要判断最少的那个东西够不够第二类人吃就行了，够就Yes，不够就No 详细见代码solve2()函数   代码如下  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long ll; typedef vector&amp;lt;int&amp;gt; vi; typedef vector&amp;lt;long long&amp;gt; vll; typedef pair&amp;lt;int, int&amp;gt; pii; typedef pair&amp;lt;long long, long long&amp;gt; pll; #define debug printf(&amp;#34;(hao)&amp;#34;) #define all(x) x.</description>
    </item>
    
    <item>
      <title>E1. Reading Books (easy version)题解</title>
      <link>https://haofish.github.io/2020/653div3probleme1/</link>
      <pubDate>Mon, 06 Jul 2020 18:00:01 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/653div3probleme1/</guid>
      <description>传送门
题意  小A和小B要读书，现在共又 n 本书，对于每本书都有三个参数，$t_i$：阅读的时间、$a_i$：小A喜欢读的书、$b_i$：小B喜欢读的书 现在小A和小B都要读 k 本书，但是他俩只读自己喜欢的书 问你小A和小B最少要读多久可以读到 k 本书，（对于都喜欢的书，时间是可以只算一次的） 如果他俩有一个没读到 k 本书就输出 -1  思路  一道思维贪心题cf好狠呀，网上有很多的解法，大多数都是模拟+贪心，但是我看到了一位大佬的贪心思路，醍醐灌顶，下面就用它的思路了 对于每个书本可以分为以下四类  小A和小B都喜欢的书 只有小A喜欢的书 只有小B喜欢的书 他俩都不喜欢的书   显然最后一类可以不管不要呀，看书长知识，目前只考虑第二三类的书，可以分别用数组$a_n$和$b_n$记录这些书的阅读时间，然后从小到大排序，精彩的来了，把$a_i 和 b_i$合成一本书当作是第一类的书（妙呀,我怎么没想到，太笨了，太菜了，刷题少），然后放入第一类，再来对第一类的书的阅读时间排序，选前 k 个书，记录阅读时间就是最终答案 代码如下  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long ll; typedef vector&amp;lt;int&amp;gt; vi; typedef vector&amp;lt;long long&amp;gt; vll; typedef pair&amp;lt;int, int&amp;gt; pii; typedef pair&amp;lt;long long, long long&amp;gt; pll; #define debug printf(&amp;#34;(hao)&amp;#34;) #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i &amp;lt; (b); i++) #define clr(a, v) memset(a, v, sizeof(a))  const int M = 2e5 + 10; vi a, b, t; void solve() { int n, k; scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;k); rep(i, 0, n) { int _t, _a, _b; scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;_t, &amp;amp;_a, &amp;amp;_b); if (_a &amp;amp;&amp;amp; _b) t.</description>
    </item>
    
    <item>
      <title>D. Zero Remainder Array题解</title>
      <link>https://haofish.github.io/2020/653div3problemd/</link>
      <pubDate>Mon, 06 Jul 2020 16:58:31 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/653div3problemd/</guid>
      <description>传送门
题意  给你一个长度为 n 的数组$a_n$，和一个 k，你有一个 x（一开始为0），你有以下两种操作  给 x 加上 1，即$x = x + 1$ 选择一个任意一个$a_i$($0 \le i &amp;lt; n$)加上 x，然后 x 加上 1   每个元素最多只能被执行一次上诉操作 问你执行上述操作，x 最小为多少可以使得数组所有元素都能整除 k  思路  记录数组的每一个数至少要加多少才可以被 k 整除 寻找上述数中的最大的众数，计算 x 加到多少才可以使得这些数都能被 k 整除。 例如  对于一个数组 {1，1，1，2，3}，k = 6 则其至少要加的数为 {5，5，5，4，3} 显然最大的众数是 5，其个数是 3，那么对于第一个 5 则需要把 x 加到 5 就行了，对于第二个 5 ，就需要再等到下一个能模 6 为 5 的数，显然就是11($5 + 6 = 11$), 而第三个 5 也是同理就是 17，但这个还不是最终答案，因为题目的第二个操作是先给数组加上 x，再让 $x + 1$,所以最终答案就是 18   为什么这样就是对的呢？很简单，如果想要执行题中把所有数都弄成可以整除 k 并且每个数只能执行一次，对于两个相同且不能被 k 整除的数 y，想要把这两个 y 都弄成能被 k 整除，第二个数 y 一定要等到下一次有一个数 x 加上这个 y 使得它能整除 k。 所以我们要求出每个数最少加多少才可以被 k 整除，然后求一个最大的众数，计算最后一个众数需要的最小x（因为最后的 x 一定是停在了能使这些最大众数的最后一个数被 k 整除的结果），记得最后的答案要再加一才是最终答案。 那么其余的非最大众数呢？别担心，这些数在为最大众数服务的时候就能有一个 x 使得他们的一些能被 k 整除。例如上面的例子，我们在把 x 走到 5 的之前就有个4，可以使得数组中的 2 加上这个 4 能被 6 整除 还想不明白就想想模数具有周期性，例如将0 ~ n中的数都摸上 3 ，就会有这么一个规律 ：0 1 2 0 1 2 0 1 2 0 1 2····· 代码如下（求众数有点滑稽，因为我不会利用简单代码的求众数的方法）  #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>C. Move Brackets题解</title>
      <link>https://haofish.github.io/2020/653div3problemc/</link>
      <pubDate>Mon, 06 Jul 2020 15:59:43 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/653div3problemc/</guid>
      <description>传送门
题意  给你一串字符串，只有&amp;rdquo;(&amp;rdquo; h和&amp;rdquo;)&amp;ldquo;组成，你每次都能选择一个字符把它移到最左边或者最右边，问你最少移动几次可以使得字符串的括号合法  思路  一道贪心题（比赛的时候没看出来，太菜了😭） 只要计算出合法的括号对，然后用总长度减去合法的括号对的个数，即剩余的不合法长度除以 2 就是最少的步数 例如 ： &amp;ldquo;()))))((((()&amp;rdquo;, 去掉合法的后就是&amp;rdquo;))))((((&amp;rdquo;, 那么移动的长度就是$8 \div 2 = 4$就是答案 这题我一开始想复杂了，对于上一个样例，我以为必须要把下标为2 ~ 5（从0开始）的先一道最左边，再把（原本的）6 ~ 9移到最左边，变成这样：&amp;quot;(((())))()()&amp;quot;,总次数是8，所以就很搞了，然而正确答案是把6 ~ 9 移到最左边就合法了，就是这样：&amp;quot;((((()))))()&amp;quot;,总次数就是 4 所以最终的思路就是判断合法的有多少对：在博客中遇到了两种方法，一种是用栈，一种是不用栈（根据括号合法的特性一定要左括号先出现， 即从头到尾遍历，用一个变量来储存左括号出现次数，一旦遇到右括号变量值就自减） 代码如下（用栈）：  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long ll; typedef vector&amp;lt;int&amp;gt; vi; #define debug printf(&amp;#34;(hao)&amp;#34;) #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i &amp;lt; (b); i++) #define clr(a, v) memset(a, v, sizeof(a))  void solve() { int n; char bra[55]; stack&amp;lt;char&amp;gt; res; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); scanf(&amp;#34;%s&amp;#34;, bra); for (int i = 0; i &amp;lt; n; i++) { if (res.</description>
    </item>
    
    <item>
      <title>B. Multiply by 2, divide by 6题解</title>
      <link>https://haofish.github.io/2020/653div3problemb/</link>
      <pubDate>Mon, 06 Jul 2020 15:01:02 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/653div3problemb/</guid>
      <description>传送门
题意  给一个数 n,问你只进行以下两种操作，要操作最少多少次能够使得 n 为 1：  把 n 除以 6 （前提是可以整除） 把 n 乘 2   输出最少的操作次数，如果无论如何都没办法得到 1，则输出 -1  思路  首先要知道的是，如果对一个数同时进行两个操作就相当于对 n 除以 3 思考一个极端的例子就是：n 的质因子只有 3，那么它一定可以最终得到 1。为什么呢？因为我们可以让每个 3 都乘 2， 这样他就有了因子 6， 便可以做第一个操作了，并且最终得到 1 如果这个数既有 2 又有 3 怎么办？ 很简单，只需要把一对 2 和 3 看成 6，最终剩下的因子如果是 2（因为已经无望再去除以 6 了），则不可能得到 1，如果是 3， 则当成只有因子 3 的数看待（即上述的极端情况） 最后一种情况就是 n 的质因子除了 3 和 2 还有其他的质因子的话，一定最终无法得到 1 所以最终的想法就是：计算出质因子 2 的个数a，和计算出质因子 3 的个数 b, 如果 $a &amp;gt; b$ 则无法得到 1，否则要操作的次数最少为 $(b - a) \times 2 + a$ 代码如下  #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>Dp总结</title>
      <link>https://haofish.github.io/2020/dp%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 01 Jul 2020 11:31:33 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/dp%E6%80%BB%E7%BB%93/</guid>
      <description>1. 写在前面的话 2. 对DP简单的总结 3. 几个重要的模型 4. 分类  ① 线性DP ② 区间DP ③ 树状DP  简介 【例题1】HDU 1520 Anniversary party 【例题2】HDU 2196 Computer   ④ 状态压缩DP  状态压缩简介 常见的二进制使用 【例题 1】HDU 方格取数（1） 【例题2】洛谷 P1879 Corn Fields G     5. 优化dp的手段  ① 矩阵优化 ② 数据结构优化 ③ 单调队列优化 ④ 决策单调性优化 ⑤ 二进制优化 ⑥ 斜率优化 ⑦ 四边形不等式优化    1. 写在前面的话  之前写了一篇不像总结的动态规划总结，感觉更像是一个成长历程，所以就打算重写一篇。  2. 对DP简单的总结   dp的题目特点</description>
    </item>
    
    <item>
      <title>动态规划刷题总结</title>
      <link>https://haofish.github.io/2020/dynamicprogramming/</link>
      <pubDate>Sat, 27 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://haofish.github.io/2020/dynamicprogramming/</guid>
      <description>1、写在前面 2、我对dp的看法和理解 3、典型例题  ①爬楼梯（leetcode #70）  题意 分析 小结      1、写在前面 这几天疯狂刷leetcode的dp题，刷到我都想吐了，看到一个题就先往dp想，感觉中毒不浅，话不多说，赶紧开始总结一下我的成长历程心得。
2、我对dp的看法和理解   首先引入《算法笔记》里的一句话:
 动态规划是一种非常精妙的算法思想，他没有固定的写法、极其灵活，常常需要具体问题具体分析。
 没错正式这种具体问题具体分析的设定让我刷到吐了
  平时在思考动态规划的往往是利用一个小小的公式：递推 = 递归 + 记忆化（下面会赘述我是怎么利用这个公式思考的）
  虽然他是这么说，但是我还是觉得dp的是有套路可循的，例如给dp分类 （背包dp、树形dp、区间dp……），经典题的记忆 （爬楼梯、树塔问题、LIS……）
  一般来说，我思考dp都是从结果往前想的（即从末尾开始想）
  dp的基本使用条件： 1. 拥有重叠子问题、 2. 最优子结构、3.无后效性
  dp思考三步走： 1. 状态定义 → 2.列状态转移方程 → 3.验证方程
  我觉得的动规成长路线：小白 → 利用小公式辅助建立dp → 正常dp三步走思维思考 → 大佬 （我还没触及 将来一定达到( ఠൠఠ )ﾉ）</description>
    </item>
    
  </channel>
</rss>