<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 🐟🐟🐟&lt;--</title>
    <link>https://haofish.github.io/posts/</link>
    <description>Recent content in Posts on 🐟🐟🐟&lt;--</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 07 Sep 2020 20:44:19 +0800</lastBuildDate>
    
	<atom:link href="https://haofish.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>UVA1625</title>
      <link>https://haofish.github.io/2020/uva1625/</link>
      <pubDate>Mon, 07 Sep 2020 20:44:19 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva1625/</guid>
      <description>Color Length  题意：给你两个长度分别为$n、m(1 \le n, m \le 5000)$的字符串，让你求出组成新串的最小$l(c)$（具体组成方式看原题） 个人感觉这题很难，一度怀疑自己的能力和紫书题目的难易分布，最后费了九牛二虎之力终于想通为什么了，所以本文可能会花大篇幅来解释这题是怎么想的 思路：一开始看着有点LCS的影子，想着想着就写出了DP的递归函数，但是却死活想不出下一步怎么递归，即如下代码的$[]$片段  int DP(int a, int b) { if (vis[a][b]) return dp[a][b]; vis[a][b] = true; int &amp;amp;res = dp[a][b]; return res = min(DP(a - 1, b) + [], DP(a, b - 1) + []); }  显然，可以猜测dp方程是  $$ dp[i][j] = min\begin{cases} dp[i - 1][j] + ?_1\ \
dp[i][j - 1] + ?_2\
\end{cases} $$
  想了好久终于还是去看了别人的博客题解，没怎么看懂，于是看了许多人的博客题解，大概知道了一件事：这题的难点就在于求 $?_1 和 \ \ ?</description>
    </item>
    
    <item>
      <title>UVA11584</title>
      <link>https://haofish.github.io/2020/uva11584/</link>
      <pubDate>Mon, 31 Aug 2020 19:20:38 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva11584/</guid>
      <description>Partitioning by Palindromes   题意：给你一个字符串，让你求分割成最少回文串的数量，比如racecar最少就是1，fastcar就是7，aaadbccb就是3
  思路：
 说实话，不放到动态规划的专题我可能都不知道怎么做 提供一种比较好想的思路：记一个长度为$l$的字符串最大的分割数量就是$l$，如果说第$l$个字符和第$l - 1$个字符拼成的字符串是回文串，则分割数量就可以减少，即将$l - 1$ ~ $l$的字符串看成一个字符，固分割数减一，以此类推往前找能够看成单个字符的回文串来求出长度为$l$的字符串的最小的分割数 设dp[i]为从0~i的字符串的最小分割数，当j + 1 ~ i是回文串时，其分割数就为dp[j] + 1，设isp[i][j]表示字符串下标从i~j是否为回文串，状态转移方程为 $$ dp[i] = min{dp[j] + 1},\ \ isp[j + 1][i] = true $$ 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; int dp[1005], len; bool isp[1005][1005]; char str[1005]; void check() { len = strlen(&amp;amp;str[1]) + 1; for (int i = 1; i &amp;lt; len; i++) { isp[i][i] = true; } for (int i = 1; i + 1 &amp;lt; len; i++) { isp[i][i + 1] = (str[i] == str[i + 1]); } for (int i = 2; i &amp;lt; len; i++) { for (int j = 1; j + i &amp;lt; len; j++) { if (str[j] == str[j + i] &amp;amp;&amp;amp; isp[j + 1][j + i - 1]) isp[j][j + i] = true; } } } void solve(){ memset(isp, 0, sizeof isp); memset(dp, 0x3f, sizeof dp); scanf(&amp;#34;%s&amp;#34;, &amp;amp;str[1]); check(); dp[0] = 0; for (int i = 1; i &amp;lt; len; i++) { for (int j = i; j &amp;gt; 0; j--) { if(!</description>
    </item>
    
    <item>
      <title>UVA11400</title>
      <link>https://haofish.github.io/2020/uva11400/</link>
      <pubDate>Mon, 31 Aug 2020 16:12:16 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva11400/</guid>
      <description>Lighting System Design   题意：你要设计一个一共需要n种不同电压灯泡的照明系统，不同种类的灯泡用不同的电源，同一种灯泡必须要用同一个电源，现在为了省钱，在亮度不减的前提下，可以用电压高的灯泡来换电压低的灯泡减小费用，现给你每种灯泡的电压V，电源费用K，每个灯泡的费用C，每种灯泡所需要的数量L，问你计算出最优的方案的费用
  思路：
 为了减少电压之间的比较可以对灯泡进行从小到大的排序，这样的话就可以默认是下标大的换下标小的 注意到对于一种灯泡，要不就全换掉，要不就全部都不换，不可能说最优的方案是当前这种灯泡只换一部分 设dp[i]表示当决策到第i种灯泡时的最优方案 将sum[i]表示前i种灯泡需要的总数量，相当于一个前缀和，则转移方程为 $$ dp[i] = max{dp[j] + (sum[i] - sum[j]) * c[i] + k[i]} $$ 解释：相当于是dp[i]的最优方案是第j + 1 ~ i种的灯泡都用第i种灯泡，然后再加上前j种灯泡中的最优方案，即dp[j] 因为每种灯泡的电压都是不一样的，所以这个方程的转移不用担心出现两种的灯泡的使用电压是一样但是电源或者灯泡的单价不一样的情况 再来就是第i种的灯泡在将前面的灯泡替换时一定是连续的，即j + 1 ~ i种是连续的不会出现断续的情况，因为如果出现断续的k（j + 1 ~ k - 1 和 k + 1 ~ i）的情况，则第k种灯泡替换成j + 1 ~ k的方案一定会比替换成i要优 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; int n, dp[1010], sum[1010]; struct lamps{ int v, k ,c, l; lamps(){} lamps(int v, int k, int c, int l) : v(v), k(k), c(c), l(l) {} }lamp[1010]; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;D:/MYCODE/vsCode-c/test.</description>
    </item>
    
    <item>
      <title>背包问题</title>
      <link>https://haofish.github.io/2020/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 22 Aug 2020 10:46:13 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <description>本文从dp总结中搬出
 背包问题是一类非常经典的动规问题，包括了==01背包==、==完全背包==、==多重背包==、==分组背包==、==混合背包==、==二维费用背包==、==背包问题求方案数==、==求背包问题的方案==、==有依赖的背包问题==（称为背包九讲）  01背包  最最经典的背包问题，背包九讲中说到：“它包含了背包问题中设计状态、方程的最基本思想。另外，别的类型的背包问题往往也可以转换成01 背包问题求解。”，固01背包的模型是非常重要的 直接看到最原汁原味的题  【例题1】AcWing 2. 01背包问题   题意不多说，就是原汁原味的01背包题，值得说的是以下内容均以V为容量，W为价值，c为背包总容量
  分析1：
 分治法这里不介绍，我也不会，这里是动规“专辑” 对于每个物品有选和不选的两种决策，固我们可以从dfs的角度加上记忆化来思考这道题 可以考虑每一层都代表一个物品，有选和不选两种方案，意味着有两个递归下去的道路 其余细节具体看代码  //调用时直接调用dfs(0, c)就好了 int dfs(int nums, int sum) {//第nums个物品，还剩下sum的容量，  if (nums == n) return 0; if (vis[nums][sum]) return dp[nums][sum]; vis[nums][sum] = true; int &amp;amp;ans = dp[nums][sum]; ans = dfs(nums + 1, sum); //不选当前的物品，则容量依旧还剩sum  if (sum &amp;gt;= v[nums]) ans = max(ans, dfs(nums + 1, sum - v[nums]) + w[nums]); // 如果容量够，则选当前物品，则容量剩余sum - v[nums]  return ans; }  可以看得出来，dfs+记忆化的好处就是简单易懂，似乎完全不用过多说明代码的意义    分析2：</description>
    </item>
    
    <item>
      <title>UVA12563</title>
      <link>https://haofish.github.io/2020/uva12563/</link>
      <pubDate>Fri, 21 Aug 2020 21:29:02 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva12563/</guid>
      <description>Jin Ge Jin Qu hao  大致题意：在KTV里，如果还剩下1秒的时间，则可以点一首更长的歌，因为他会播放完最后一首歌才停止，现在给你剩下的时间$m$和$n(n \le 50)$首歌，每首歌的时长$t_1, t_2, t_3 ……t_n$，现让你算出在剩余的时间内能唱的歌的最大数量，然后利用空出来的时间最后再点一首长为678秒的歌，输出能唱的最大数量，对应的时间 简单的分析：  题目中说最后会点一首678秒的歌来延长时间，则策略就是计算在不超过$m - 1$时间里选最多的歌 读一读上面的一句话，是不是感觉很想01背包？是的就是01背包问题，每个物品的价值默认是1了（一首歌嘛） 题目中说$m \le 10^9$，其实并没有这么大，~~我一开始也很苦恼这怎么建数组，~~后来发现其实并没有这么大，他说n + 1首歌的时长严格大于剩余的时长，并且每一首歌不会超过3分钟，这么算的话$180 \times 50 + 678 = 9678$，固数组完全够开 值得注意的是这题计算在选歌的数量多的前提下最后尽量晚地结束KTV，这就需要讨论了，一开始被这个搞得十分地晕，冷静下来后发现一个if是不够的，于是就特判3次  首先如果当前抉择的歌曲数量还没之前算的多，直接跳过 如果当前抉择的歌曲数量严格比之前算的还多，则更新歌曲数量和时间总长度 如果当前抉择的歌曲数量和之前算的一样多，则还要判断当前抉择的时长是严格比上次算还多，则更新时间总长度   具体看代码    #include &amp;lt;cstring&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; int n, t, dp[10010], m, kase = 0, sum[10010]; void solve() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); memset(dp, 0, sizeof dp); memset(sum, 0, sizeof sum); for (int i = 0; i &amp;lt; n; i++) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); for (int j = m; j &amp;gt; t; j--) { if (dp[j] &amp;gt; dp[j - t] + 1) continue;//特判1  if (dp[j] &amp;lt; dp[j - t] + 1) { //特判2  dp[j] = dp[j - t] + 1; sum[j] = sum[j - t] + t; } else if (sum[j] &amp;lt; sum[j - t] + t){//特判3  sum[j] = sum[j - t] + t; } } } printf(&amp;#34;Case %d: %d %d\n&amp;#34;, ++kase, dp[m] + 1, sum[m] + 678); } int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;D:/MYCODE/vsCode-c/test.</description>
    </item>
    
    <item>
      <title>UVA116</title>
      <link>https://haofish.github.io/2020/uva116/</link>
      <pubDate>Fri, 21 Aug 2020 14:36:57 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva116/</guid>
      <description>Unidirectional TSP   大致题意：有个$m \times n$矩阵，对于每个点你可以向直接向右、右上，右下走，第1行的上一行是第m行，第m行的下一行是第1行，问你从第一列的某一行出发，到达最后一列所经历的点的和最小是多少，并且打印出每一列的行号，如果有多解，输出字典序最小的
  简单的分析：
 可以看出是一个数塔问题的变种 书中说这种问题叫做多阶段决策问题中的一类——多阶段图的最短路问题，所谓多阶段图按书中说法就是图中结点可以划分成若干个阶段 这里我的理解就是原数塔问题也可以说是一个DAG，而这题相当于多个数塔重合的版本，固每一列都有对应着不用的阶段 计算最短路就是简单的数塔解法了 真正让人头疼的是最小字典序这里，一开始我的做法是写一大堆if判断，最后对比了一下刘老师的代码，妙不可言，用了大小为3的数组存下一列的决策行数 代码如下  #include &amp;lt;cstring&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; const int INF = 0x3f3f3f3f; int m, n, g[15][110], ans[15][110], Min, dp[15][110], f; bool vis[15][110]; int DP(int r, int c) { if (c == n) return 0; if (vis[r][c]) return dp[r][c]; int &amp;amp;res = dp[r][c], M = INF, &amp;amp;i = ans[r][c + 1], row[] = {r - 1, r, r + 1}; vis[r][c] = true, res = g[r][c]; if (r == 0) row[0] = m - 1; if (r == m - 1) row[2] = 0; sort(row, row + 3); for (int j = 0; j &amp;lt; 3; j++) if (M &amp;gt; DP(row[j], c + 1)) M = DP(row[j], c + 1), i = row[j]; res += M; return res; } int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;D:/MYCODE/vsCode-c/test.</description>
    </item>
    
    <item>
      <title>UVA437</title>
      <link>https://haofish.github.io/2020/uva437/</link>
      <pubDate>Fri, 21 Aug 2020 09:46:38 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva437/</guid>
      <description>The Tower of Babylon  题意：给你n种有无数个的立方体，现在让你用这些立方体堆一个塔，每个立方体的底面长宽都要严格小于下面立方体的底面长宽，问你最高能堆多高 简单的分析  能看得出来是一个矩形嵌套的变种问题，用DAG模型建立来做会非常好码代码 一种立方体有三种摆放方式，假设一个立方体的长宽高为a、b、c，则三种摆放方式分别是以a、b、c为高的摆放方式，固一种立方体可以看成三个立方体 下面就是建立DAG了，如果一个立方体的底面长宽严格大于另一个底面长宽的立方体则连一条有向边过去 最后就DP就是求从某个节点出发的最大距离就是答案 注意到，无论是思考还是码代码都不需要再去想状态方程来，直接当成一个图求最远距离来做，为了加速，我用了邻接表来建立图 下面是代码    #include &amp;lt;cstring&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; int n, kase = 0, head[100], cnt = 0, dp[500], vis[500]; struct rect{ int a, b, c; rect(){} rect(int a, int b, int c) : a(a), b(b), c(c) {} }r[100]; struct edges{ int to, next; edges(int to = 0, int next = -1) : to(to), next(next) {} }edge[10010]; bool ok(const rect&amp;amp; x, const rect&amp;amp; y) { return (x.</description>
    </item>
    
    <item>
      <title>UVA1025</title>
      <link>https://haofish.github.io/2020/uva1025/</link>
      <pubDate>Thu, 20 Aug 2020 19:32:31 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva1025/</guid>
      <description>A Spy in the Metro  本篇是由DP总结中搬出的，目的是记录刷题进度 大致题意：一个线性的地铁，有$n(2 \le n \le 50)$个站，目标是在$T(0 \le T \le 200)$时刻从1号站到n号站，注是规定刚好T时刻，不是在T时刻之前也不是在T时刻之后，从1号点出发，可以在途中转乘，问你最少的中途等车时间  第i站到第i + 1站需要花的时间为$t_i$ 有$M1(M1 \le 50)$个车从1号站出发，出发时间分别为$d_1, d_2, d_3……, d_{M1}\ \ (d_i &amp;lt; d_{i + 1}, d_i \le 250)$，同样有M2个车从n号站出发，时间格式同上 其余细节看题   简单分析：  就看当先的状态，假设现在的时间是tim，正在第p个站有三种策略  等1分钟，剩下的下一分钟再说 如果有向1号站行的车，乘坐上去 如果有向n号站行的车，乘坐上去   那么这个是怎么建立DAG图的呢，对于每个点，定义它包括的属性有时间和站点，如果当前时间当前站点有开往下个一或者上一个站的车，则将到站的时间和对应的站点连一条有向的边，例如当前时间是15，站点是3，并且有开向第2站点的车，10单位的时间后到达，但没有向下一个站开的车，则在属性为（15，3）的节点连一条有向边到（25，2）的节点， 当然千万别忘了一点就是下1单位时间的同一站点也有一条边，即（15，3）到（16，3）也有一条有向边 然后就可以利用这个DAG图的节点属性来定义状态了，即设dp[p][tim]为在p站点tim时刻的状态，既然是求最小路，则状态就是到当前节点的最短路 对应三种策略的状态转移方式  当前的状态等于下一单位时间的状态加1的等待时间 当前状态等于到站后的时间和站点的状态 同上   最后取一个最小值 边界条件就是如果在T时刻和n站点刚好到达，则返回0，因为不用等了，如果超过了T时间，则说明是从某个站点到另一个站点后时间过了，则返回无穷大表示不用等了，如果刚好到T时刻且没到达n站点，则说明后面再怎么坐车时间也过了，也返回无穷大 说了这么多，却没写状态转移方程是因为打算使用记忆化来做，所有不用转移方程，直接考虑当前递归的来自哪些结果就好了 代码如下    #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; const int INF = 0x3f3f3f3f; int n, T, t[100], kase = 0, dp[110][210]; bool has_train[110][210][2], vis[110][210]; bool read() { int m, x; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); if(!</description>
    </item>
    
    <item>
      <title>UVA1149</title>
      <link>https://haofish.github.io/2020/uva1149/</link>
      <pubDate>Tue, 18 Aug 2020 15:50:53 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva1149/</guid>
      <description>Bin Packing  题意：给你n个物品，每个物品的重量为$w_i$，你有容量为w的背包，每个背包最多只能装两件物品，问你最少要多少背包来装 贪心就好了，贪心策略：将物品按重量排序，如果最重和最轻的物品一起不超过w就放一起，然后就让次重和次轻的放一起；否则重的单独放在一个背包，然后让次重的背包和最轻的一起，以此循环 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; const int M = 1e5 + 5; int n, w, wi[M]; int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;D:/MYCODE/vsCode-c/test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;D:/MYCODE/vsCode-c/test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  int t; scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); while (t--) { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;w); for (int i = 0; i &amp;lt; n; i++) scanf(&amp;#34;%d&amp;#34;, wi + i); sort(wi, wi + n); int l = 0, r = n - 1, ans = 0; while (l &amp;lt;= r) { if (wi[l] + wi[r] &amp;lt;= w) l++, r--; else r--; ans++; } if (t) printf(&amp;#34;%d\n\n&amp;#34;, ans); else printf(&amp;#34;%d\n&amp;#34;, ans); } return 0; } </description>
    </item>
    
    <item>
      <title>UVA11572</title>
      <link>https://haofish.github.io/2020/uva11572/</link>
      <pubDate>Tue, 18 Aug 2020 11:57:07 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva11572/</guid>
      <description>Unique Snowflakes  题意：给你一个长度为$n(n \le 1000000)$的数组，问你最长有不重复数字的连续子序列有多长 用set和map的速度都差不多，set记录是否重复，map记录当前数字在此之前最近出现的位置，如果没有就是-1 如果嫌set和map慢的话直接用unordered_set或者unordered_map 这里用了上次偶遇了一种很牛逼很简洁的hash方式后就喜欢上这个hash，跑进了100ms 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; const int M = 1e6 + 10, H = 0xfffff; int n, arr[M], last[M]; struct Hash{ int real[H + 5], val[H + 5]; void clear() { memset(val, -1, sizeof val); }//初始化-1  int&amp;amp; operator[] (const int &amp;amp;k) { int i = k &amp;amp; H; while (real[i] != k &amp;amp;&amp;amp; ~val[i]) i = (i + 1) &amp;amp; H; real[i] = k; return val[i]; } }h; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;D:/MYCODE/vsCode-c/test.</description>
    </item>
    
    <item>
      <title>UVA11054</title>
      <link>https://haofish.github.io/2020/uva11054/</link>
      <pubDate>Tue, 18 Aug 2020 10:55:44 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva11054/</guid>
      <description>Wine trading in Gergovia  题意：有n个村庄，每个村庄都有对酒的需求，正数代表要送出多少酒，负数代表需要多少酒，把k单位的酒运到相邻的村庄要k单位的体力，让你计算最小需要的体力 对于第一个村庄，他的需求量x无论正负，都需要右边的村庄搬过来或者搬过去右边的村庄，然后把多余的需求继承到下一个村庄，和紫书上讲的思想差不多 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cmath&amp;gt; using namespace std; using ll = long long; const int M = 1e5 + 10; int n; ll arr[M], ans; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;D:/MYCODE/vsCode-c/test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;D:/MYCODE/vsCode-c/test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;n), n) { ans = 0; for (int i = 0; i &amp;lt; n; i++) { scanf(&amp;#34;%lld&amp;#34;, arr + i); } for (int i = 0; i &amp;lt; n - 1; i++) { ans += abs(arr[i]), arr[i + 1] += arr[i]; } printf(&amp;#34;%lld\n&amp;#34;, ans); memset(arr, 0, sizeof arr); } return 0; } </description>
    </item>
    
    <item>
      <title>UVA1152</title>
      <link>https://haofish.github.io/2020/uva1152/</link>
      <pubDate>Mon, 17 Aug 2020 19:54:27 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva1152/</guid>
      <description>4 Values whose Sum is 0  题意：给你4个长度为$n(n \le 4000)$的集合，让你在4个集合里分别取a、b、c、d，使得$a + b + c + d = 0$，问你有多少种取法 按紫书说的“中途相遇法”，从象个不同的方向来解决问题，最终“汇集”在一起 用哈希记录$a + b$，然后再计算$-c - d$的哈希个数就好了，用slt提供的unordered_map足够过这题了，跑了6000ms多，a掉了 后来看了一位大佬自己写的hash，跑了一下，平均650ms，一个很快的哈希表 原理大概和线性探查法差不多，不过这里用的不是取余（取余很慢），这里用的位运算里的与运算，保证了数值在给定的哈希范围内 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; const int M = 4e3 + 10, H = 0x7fffff; int n, arr[5][M]; struct Hash{ int real[H + 5], val[H + 5] void clear() { memset(val, 0, sizeof val); } int&amp;amp; operator[] (const int&amp;amp; num) { int i = num &amp;amp; H; while (val[i] &amp;amp;&amp;amp; real[i] !</description>
    </item>
    
    <item>
      <title>UVA1605</title>
      <link>https://haofish.github.io/2020/uva1605/</link>
      <pubDate>Mon, 17 Aug 2020 11:43:31 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva1605/</guid>
      <description>Building for UN  题意：有一栋楼，有$n(n \le 50)$个国家要开会，每个国家至少分配一个位置，让你输出一种方案，H层，每层W行L列，使得任意两个国家要能相邻，层数也算相邻 按紫书说的构造一种解出来，只需要两层就好了，每层$n \times n$的格子，第一层第i行是第i个国家,第二层第j列是第j个国家， 这个模型有点像放筷子，有n双筷子，分别都有左和右，要想让每个左筷子都能接触到其他右筷子的方案就是在第一层筷子横着放，第二层竖着放就行了 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std; int n; char str[55]; void solve() { printf(&amp;#34;%d %d %d\n&amp;#34;, 2, n, n); for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; n; j++) printf(&amp;#34;%c&amp;#34;, str[i]); puts(&amp;#34;&amp;#34;); } puts(&amp;#34;&amp;#34;); for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; n; j++) printf(&amp;#34;%c&amp;#34;, str[j]); puts(&amp;#34;&amp;#34;); } } int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;D:/MYCODE/vsCode-c/test.</description>
    </item>
    
    <item>
      <title>UVA120</title>
      <link>https://haofish.github.io/2020/uva120/</link>
      <pubDate>Mon, 17 Aug 2020 11:16:52 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva120/</guid>
      <description>Stacks of Flapjacks  题意：给你一个序列，每次选一个数k，从序列的后往前数第k个数然后把它及它之前时数都翻转一下，问你一种选法使得序列从小到大排好序 有点像选择排序，不过为了不影响后面的，应该先把排好最大的数，如果已经就位就排第二大的数，具体策略是先把它调到最前面再调到相应的正确位置，一直排到有序为止 代码如下  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; int cnt, arr[50], tmp[50]; char line[150]; void solve() { memcpy(tmp, arr, sizeof(int) * cnt); sort(tmp, tmp + cnt); int indx = cnt - 1; for (int i = cnt - 1; i &amp;gt;= 0; i--) { if (tmp[indx] == arr[i]) { indx--; } else { int nums = i, k = cnt - i; while (arr[nums] !</description>
    </item>
    
    <item>
      <title>UVA12558</title>
      <link>https://haofish.github.io/2020/uva12558/</link>
      <pubDate>Sun, 16 Aug 2020 21:28:14 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva12558/</guid>
      <description>Egyptian Fractions (HARD version)  题意：埃及分数问题困难版，问你一个真分数$a/b$，在表达成$a/b = 1/c + 1/d ……$，选的分数尽量少，相同情况下自小的分数尽量大，限制有$k(k \le 5)$个数不能用来做分母，让你求解 思路，IDA*的经典题，和普通埃及分数差不多的写法，就是要加一个限制，即有些数不能用 一开始写了一个分数的结构体，后来发现没必要，直接IDA*就好了 注意几个剪枝的地方，  到达目标层时  判断分子是否为1 判断最后一个分母是否重复 判断最后一个分母是否可用 判断是否是更优解   未达到目标层时  预测选用当前的抉择是否会超出目标层（IDA*的关键剪枝） 判断当前抉择的分母是否可用     代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; using ll = long long; ll kase = 0, can[1005], k, ans[10000], tmp[10000], a, b, x; ll gcd(ll a, ll b) { ll m = 1; while(m) m = a % b, a = b, b = m; return a; } bool dfs(ll now, const ll &amp;amp;h, ll first, ll a, ll b) { if (now == h) { if (a !</description>
    </item>
    
    <item>
      <title>UVA12113</title>
      <link>https://haofish.github.io/2020/uva12113/</link>
      <pubDate>Sat, 15 Aug 2020 17:16:11 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva12113/</guid>
      <description>Overlapping Squares  题意：给你个$4 \times 4$的网格图，问你有没有可能用不超过6张$2 \times 2$的纸叠成给的样子 一开始想破脑袋都想不出来应该怎么验证是否相同，没办法还是问了下度娘，知道思路后自己写了代码ac了 想不出的是如何验证正确性，一开始想着是否要把被遮住的部分补全然后验证，但这样又怎么验证？看了看别人的思路发现自己是真的蠢，直接模拟用$2 \times 2$的纸一张一张地放上去不就好了吗 dfs最多也就6层，纸放下去只有9种可能，能想到这里就可以直接dfs模拟了 ac代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; char g[10][20], p[10][20]; bool vis[10]; bool init() { for (int i = 0; i &amp;lt; 5; i++) { fgets(g[i], 15, stdin); if (g[i][0] == &amp;#39;0&amp;#39;) return false; } memset(p, &amp;#39; &amp;#39;, sizeof p); memset(vis, 0, sizeof vis); return true; } bool check() { for (int i = 0; i &amp;lt; 5; i++) { for (int j = 0; j &amp;lt; 9; j++) if (p[i][j] !</description>
    </item>
    
    <item>
      <title>UVA690</title>
      <link>https://haofish.github.io/2020/uva690/</link>
      <pubDate>Fri, 14 Aug 2020 12:22:46 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva690/</guid>
      <description>Pipeline Scheduling  历经千辛万苦终于a了这题 题意：一台电脑有5个工作单元(unit0 ~ unit4)，有10(0 ~ 9)个程序需要完成，每个程序都要在n$(n &amp;lt; 20&amp;gt;)$的时间片完成，在同一时间里，一个单元只能执行一个程序，开始执行后就要严格按顺序执行完，问你最小的完成10个程序的时间是多少 从读题到思考到ac用了近两天，下面我将会从运行时间慢到运行时间快，tle到ac开始阐释解决这题时的坎坷 首先是这题怎么dfs  一开始想的时候想到了一个最笨的方法：根据时间一步一步地dfs下去，但这样的话绝对不行，因为如果n = 19,最多会递归190层，就算考虑剪枝，如果答案就是上百的，那也受不了 想了很久终于想到一个办法就是根据程序来递归，即递归（0 ~ 9）这样的话最多也就9层 用一个二维的bool数组run[i][j]来储存状态，代表第i个工作单元在j时间时的运行情况，false代表是空闲的，true代表是正在工作 对于一开始第一个程序即程序0肯定就是从0时刻时开始运行是最优的，所以dfs从程序1开始 对于第$k$个程序来说，如果开始的时间是$s$，则它结束的时间一定是$s + n$，则第$k + 1$个程序可以在$s + 1$到$s + n + 1$之间（包括端点）的时间里开始运行 到这里dfs的运行方式就很明朗了，只需要暴力枚举每个$s + 1$到$s + n + 1$的位置开始运行下一个程序就行了 那么剪枝呢？这个dfs的方法直接对比先前算好最小完成时间的和当前程序的结束时间做对比来剪   上述的方法是会tle的，先别急，一步一步走到ac这个开头不能少 上述dfs方法的代码  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; int n, Min; char unit[6][25]; bool run[5][500]; bool check(int s) { for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; 5; j++) if (unit[j][i] == &amp;#39;X&amp;#39; &amp;amp;&amp;amp; run[j][i + s]) return false; return true; } void dfs(int num, int s) { if (s + n &amp;gt;= Min) return; if (num == 10) { Min = s + n; return; } for (int i = s + 1; i &amp;lt;= s + n; i++) { if (!</description>
    </item>
    
    <item>
      <title>UVA211</title>
      <link>https://haofish.github.io/2020/uva211/</link>
      <pubDate>Thu, 13 Aug 2020 14:46:51 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva211/</guid>
      <description>The Domino Effect  题意：一个多米诺骨牌有两个面，一共有28个不同的多米诺骨牌，放在那，可能横着，可能竖着，这样就形成了一个$7 \times 8$的一个数字图，问你所有可能的摆放方式 dfs就好了，一开始没想到怎么dfs，绞尽脑汁，一开始一格一格来，失败，后来采用每一行都用一个二进制状态来描述是横还是竖，还是失败了，最后看了下题解，豁然开朗 也是dfs，但是不能再单纯地一格一格得dfs，要一行一行来，不然可能会像我一开始那样，会遗漏很多格子没递归到，所以要一行一行来，方式就是每行一格一格地递归，递归到最后一列的才换行（代码24行处），最终将28个牌都遍历一遍才能输出 至于骨牌号码的储存方式，考虑到数据小，所以用了压缩来储存起骨牌的号码 代码如下  #include &amp;lt;cstring&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; int domi[10][10], id[400], ans[10][10], nums = 0, kase = 0; bool vis[30]; const int dr[] = {1, 0}, dc[] = {0, 1}; inline int ID(int a, int b) { return (min(a, b) &amp;lt;&amp;lt; 6) | max(a, b); } inline bool check(int r, int c) { return r &amp;lt; 7 &amp;amp;&amp;amp; c &amp;lt; 8; } void init(){ memset(ans, 0, sizeof ans); memset(vis, 0, sizeof vis); nums = 0; } void dfs(int r, int c, int num) { if (num == 28) { nums++; for (int i = 0; i &amp;lt; 7; i++) { for (int j = 0; j &amp;lt; 8; j++) { printf(&amp;#34;%4d&amp;#34;, ans[i][j]); } puts(&amp;#34;&amp;#34;); } puts(&amp;#34;\n&amp;#34;); return; } if (c == 8) r++, c = 0; if (ans[r][c]) { dfs(r, c + 1, num); return; } for (int i = 0; i &amp;lt; 2; i++) { int newr = r + dr[i], newc = c + dc[i]; int x = ID(domi[r][c], domi[newr][newc]), res = id[x]; if (!</description>
    </item>
    
    <item>
      <title>UVA225</title>
      <link>https://haofish.github.io/2020/uva225/</link>
      <pubDate>Wed, 12 Aug 2020 15:54:08 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva225/</guid>
      <description>Golygons  题意：一个网格图，现在给你图中$k(k \le 50)$个障碍的坐标（坐标可能为负），不能继续上次的方向继续走也不能后退，这就意味着只能左右走，第$i$次走$i$个单位，从(0, 0)点出发，走了$n(n \le 20)$次恰好回到(0, 0)点，让你输出所有可能的路线，按字典序输出 因为深度已知，所以我才用了DFS的方法，考虑到坐标可能有负数，所以我把坐标原点移动了一下，将(1000, 1000)记为原点，其余点也一样有同样变化，因为 $n \le 20$， 所以1000够用 将答案用vector&amp;lt;char&amp;gt;的一维数组存起来，因为vector里面自带字典序的排序，所以最后可以直接sort(ans, ans + num)排序（详细看代码），当然用vector&amp;lt;string&amp;gt;来存，这样就不用再而外加多一维数组了，string也有push_back()（用append()也可以）和pop_back()函数，这样最后的排序就必须是sort(ans.begin(), ans.end()); 一个方案中一个坐标不能被访问两次，用个vis的布尔数组来记录是否被访问过 dfs两次，因为最开始是4个方向都可以走的 最后记得回溯 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; const int M = 1e3; int t, k, bn, num; bool isb[M + M][M + M], vis[M + M][M + M]; const char dir[] = &amp;#34;ewns&amp;#34;; const int dx[] = {1, -1, 0, 0}; const int dy[] = {0, 0, 1, -1}; vector&amp;lt;char&amp;gt; ans[1000], tmp; void init() { num = 0; memset(isb, 0, sizeof isb); memset(vis, 0, sizeof vis); for (auto &amp;amp;i : ans) i.</description>
    </item>
    
    <item>
      <title>UVA208</title>
      <link>https://haofish.github.io/2020/uva208/</link>
      <pubDate>Wed, 12 Aug 2020 10:24:20 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva208/</guid>
      <description>Firetruck  题意：给你一个无向图，让你求出从1号节点到n号节点的所有路径，按顺序输出，具体看样例 DFS和BFS都可以，这里我用了DFS，利用了一个ans的vector数组来储存答案，根据题目要求，优先递归节点权值小的 注意：要先判断1号节点能否到达n号节点，不然会tle，这里我用了一个类似于并查集的思想来判断是否能到达n号节点 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; using vi = vector&amp;lt;int&amp;gt;; int t, cnt, Kase = 0, nums, fa[25]; bool vis[25], f, num[25], v[25]; vi nodes[25], ans; void init() { cnt = 0, nums = 0; for (auto &amp;amp;i : nodes) i.clear(); ans.clear(); ans.push_back(1); memset(num, 0, sizeof num); memset(vis, 0, sizeof vis); memset(v, 0, sizeof v); vis[1] = true; for (int i = 1; i &amp;lt; 25; i++) fa[i] = i; } void DFS(int n) { if (n == t) { cnt++, f = true; for (auto i : ans) { if (f) f = !</description>
    </item>
    
    <item>
      <title>UVA11212</title>
      <link>https://haofish.github.io/2020/uva11212/</link>
      <pubDate>Tue, 11 Aug 2020 10:02:22 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva11212/</guid>
      <description>Editing a Book  题意：给你一个排列，你一次能够剪切一段字串，然后在别的地方插入粘贴，让你求最少的剪切粘贴次数使得排列是1~n按顺序的 IDA*的题，每次规定递归的层数，长度为n的排列最多是剪切粘贴n - 1次 剪枝精髓：移动一次最多改变 3 个数字的后继数字，例如从{a，b，c，d}到{a, c, b, d},只有a, c, b（字母均代表区间）三个区间最后一个数的后继改变了 假设当前递归到d层，还有h个数字的后继不正确（最后一个数字的评判依据是是否是最后一个数，即$n - 1$），的最少还要遍历 $d + h / 3$ 层，当前设置了最大层数为Max, 则当 $d + h / 3 &amp;gt; Max$ 即 $3 \times d + h &amp;gt; 3 \times Max$ 就剪枝 代码如下，跑了300ms  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; int n, arr[15], tmp[15], kase = 0; bool check() { for (int i = 0; i &amp;lt; n; i++) { if (arr[i] !</description>
    </item>
    
    <item>
      <title>UVA1601</title>
      <link>https://haofish.github.io/2020/uva1601/</link>
      <pubDate>Mon, 10 Aug 2020 17:00:48 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva1601/</guid>
      <description>The Morning after Halloween  题意：给你一个图，&amp;quot;#&amp;ldquo;为障碍物，&amp;rdquo; &amp;ldquo;为通路，图里面最多有3个小写字母（a, b, c）和于其对应的大写字母（A, B, C），每次移动每个小写字母都有4个方向和不动5种方案，一次移动可以有多个小写字母一起移动，不能一个空格点不能同时有多个小写字母，问你最少要移动多少次才能让这些小写字母移动到对应的大写字母上 受紫书的启发，了解到了一个规矩图或者迷宫亦或是题目给的不是图（例如上次的倒水题），也能够利用“状态”来简化成一个平时我们更多看到的点对点的图，看来是几个能够相互连接产生关系的状态，就能考虑利用状态图来解 这题的“状态”是对每个坐标的压缩，压缩成一个一维的标志，看起来就好像是给每家每户上一个门牌号一样，因为坐标最大是（16, 16），也就是说最多有256个“门牌号”，这对于一个图来说还是有点多，幸运的是题中说每 $2 \times 2$ 的格子至少有一个可走的点，这样我们只要考虑可以走的点就行了 按出现顺序给可走的点编上“门牌号”，并记录上字母的门牌号 还要记录每个点能到哪些点，这样就能当成一个有向图来看了 如果题目给的鬼的数量不到3个，那可以假装他给了，为没给的字母强行加个门牌号，并且他们已经到了自己的目的地，即相应的大小写字母在同一个位置 以下代码是单向的BFS, vj上测得是930ms  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cctype&amp;gt; using namespace std; const int M = 210, f = 0xff; char g[M][M]; int w, n, h, s[3], t[3], id[20][20], dir[M][M][M]; const int dx[] = {-1, 0, 1, 0, 0}; const int dy[] = {0, -1, 0, 1, 0}; inline bool check(int x, int y) { return x &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt;= w &amp;amp;&amp;amp; y &amp;lt;= h; } inline int ID(int a, int b, int c) { return (a &amp;lt;&amp;lt; 16) | (b &amp;lt;&amp;lt; 8) | c; }//状态压缩 inline bool move(int a, int b, int ago, int bgo) {//检车移动是否合法，即不能一步交换位置，不能到同一个位置  return (a == bgo &amp;amp;&amp;amp; b == ago) || ago == bgo; } struct pos{ int x, y, n, go[5]; } p[200]; void BFS() { memset(dir, -1, sizeof dir); queue&amp;lt;int&amp;gt; q; q.</description>
    </item>
    
    <item>
      <title>UVA10603</title>
      <link>https://haofish.github.io/2020/uva10603/</link>
      <pubDate>Sun, 09 Aug 2020 20:37:14 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva10603/</guid>
      <description>Fill  题意：给你3个没有刻度的杯子，每个杯子的都有自己的容量，现利用这三个杯子量出体积为d的水，现在问最少的倒水量，如果量不到d，就量和d想接近的d&amp;rsquo; 按照书中的说法这是一个隐式图，求最短路，最短路的评判标志是倒水量  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;queue&amp;gt; using namespace std; const int M = 210; int cap[3], d, ans[M]; bool vis[M][M]; struct nodes{ int v[3], d; nodes(){} nodes(int v0, int v1, int v2, int d) :d(d) { v[0] = v0, v[1] = v1, v[2] = v2; } bool operator &amp;lt; (const nodes&amp;amp; tmp) const { return d &amp;gt; tmp.d; } }; void init() { memset(ans, -1, sizeof ans); memset(vis, 0, sizeof vis); } void update(nodes &amp;amp;u) { for (int i = 0; i &amp;lt; 3; i++) { if (ans[u.</description>
    </item>
    
    <item>
      <title>UVA1354</title>
      <link>https://haofish.github.io/2020/uva1354/</link>
      <pubDate>Sun, 09 Aug 2020 15:45:24 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva1354/</guid>
      <description>Mobile Computing  题意：有一个房间，有长为1的木棍，用天平的方式放一些物品，让你求出不超过房间的宽度的最长宽度的，如果误解输出-1 做了两天，习得了两种dfs非枚举子集的办法（到时再回头研究刘神方法），只选择了一种学习，当然另一种也看了 自底向上枚举二叉树，思想有点像哈夫曼建树，选择两个节点来合并，然后就是递归回溯的事 dfs(n) ：代表还剩下 n 个节点可以拼接 w[i] ：代表第 i 个节点的重量，w[i] = 0 则表示该节点已经被用了 l[i]、r[i] ：代表第 i 节点的左右宽度的最大值 值得注意的是在求 l[i] 和 r[i] 时同时要考虑当前另一个节点，例如在计算 l[i] 时，不仅要考虑 左子树的左最大宽度 + 当前节点的左宽度，还要考虑 右子树的左最大宽度 - 当前节点的右宽度，前者很好理解，关键是后者：因为有可能右子树的左最大宽度会超过左子树 具体看图，右子树同理   显然橙色节点的距离超过了黄色节点 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; using vi = vector&amp;lt;int&amp;gt;; double d, Max, l[10], r[10]; int n, cnt, k = 0; vi w; void dfs(int num) { if (num == 1) { for (int i = 0; i &amp;lt; n; i++) { if (!</description>
    </item>
    
    <item>
      <title>UVA140</title>
      <link>https://haofish.github.io/2020/uva140/</link>
      <pubDate>Fri, 07 Aug 2020 19:53:14 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva140/</guid>
      <description>Bandwidth  题意：给你一个无向图，让你输出一种序列使得每个节点到该节点在图中相连的节点的最远距离的最小值，直接看题目比较好懂 dfs遍历所有可能的序列，然后求出一个最小值，我的代码用了邻接表 剪枝的话一种是利用计算好最小带宽的一种来剪枝，第二种就是计算未确定位置的节点的最小带宽来剪 按照紫书的指导，剪了两种枝，但是感觉剪一种的速度差不多，两者交上去都是$0ms$，毕竟节点不多，剪一种枝就行了 以下代码是剪了两种枝的，如果只剪一种，只要把28，60，62注释就行了  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; char str[200]; bool ext[26], ok[26][26]; int head[26], n, indx[26], vis[26], mind, con[26]; struct es{ int to, next; es(int to = 0, int next = -1) : to (to), next(next) {} }; vector&amp;lt;es&amp;gt; e; vector&amp;lt;char&amp;gt; node, res, ans; void add_edge(int u, int v) { e.push_back(es(v, head[u])); head[u] = e.size() - 1, con[u]++; if (!ext[u]) node.push_back(u + &amp;#39;A&amp;#39;); ext[u] = true; } bool check(int cur, int u) { if (!</description>
    </item>
    
    <item>
      <title>UVA129</title>
      <link>https://haofish.github.io/2020/uva129/</link>
      <pubDate>Fri, 07 Aug 2020 11:57:39 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva129/</guid>
      <description>Krypton Factor  定义一个串是容易串：有相邻的相同的字串；反之就是困难串 让你求只利用前k个大写字母的第n个困难串 dfs模拟一下，值得注意的是剪枝时只看当前串的后缀即可，例如遍历到ABCDEFGH时，就只判断H和G、GH和EF、FGH和CDE、EFGH和ABCD就行了 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; int n, L, num = 0; bool ok = true; char ans[100], a[50], b[50]; bool check(int len) { if (!len) return false; for (int i = 1; i + i &amp;lt;= len + 1; i++) { memcpy(a, &amp;amp;ans[len - i + 1], sizeof(char) * i); memcpy(b, &amp;amp;ans[len - i - i + 1], sizeof(char) * i); a[i] = &amp;#39;\0&amp;#39;, b[i] = &amp;#39;\0&amp;#39;; if (strcmp(a, b) == 0) return true; } return false; } void dfs(int cur) { if (num &amp;gt; n) return; if (num == n) { size_t len = strlen(ans), s = 0, l = 0; for (size_t i = 0; i &amp;lt; len; i++) { if (s++ == 4) { if (l !</description>
    </item>
    
    <item>
      <title>UVA524</title>
      <link>https://haofish.github.io/2020/uva524/</link>
      <pubDate>Thu, 06 Aug 2020 20:32:38 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva524/</guid>
      <description>Prime Ring Problem  题意：给你一个数n，让你求出所有素数环，素数环：利用 1 ~ n来排列组合成的一个环，相邻的两个数的和必须都是素数 直接dfs遍历所有排列，途中要剪枝，如果当前放的数和前面的数的和不是素数就直接剪了 画出解答树更好懂 代码如下  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; int kase = 0, n, arr[30]; bool isp[] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0}; bool vis[30]; void dfs(int cur, int *A) { if (cur == n - 1) { if (!</description>
    </item>
    
    <item>
      <title>UVA10976</title>
      <link>https://haofish.github.io/2020/uva10976/</link>
      <pubDate>Thu, 06 Aug 2020 18:27:25 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva10976/</guid>
      <description>Fractions Again?!  给你一个k,让你求所有 $1 / k = 1 / x + 1/ y$ 的答案 $x \ge y$ 计算可以发现 y 最大不会超过2k,最小是k + 1  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; using ll = long long; ll n; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (~scanf(&amp;#34;%lld&amp;#34;, &amp;amp;n)) { vector&amp;lt;ll&amp;gt; a, b; for (ll i = n + 1; i &amp;lt;= n + n; i++) { if (n * i % (i - n) == 0) { a.</description>
    </item>
    
    <item>
      <title>UVA11059</title>
      <link>https://haofish.github.io/2020/uva11059/</link>
      <pubDate>Thu, 06 Aug 2020 17:34:18 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva11059/</guid>
      <description>Maximum Product  给你一个数组，让你求子字串的最大乘积，如果没有就输出0 暴力解就好了  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; using ll = long long; int n, kase = 0; int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while(~scanf(&amp;#34;%d&amp;#34;, &amp;amp;n)) { ll Max = 0; vector&amp;lt;ll&amp;gt; arr(n); for (auto &amp;amp;x : arr) scanf(&amp;#34;%lld&amp;#34;, &amp;amp;x); for (int i = 0; i &amp;lt; n; i++) { ll tmp = arr[i]; Max = max(Max, tmp); for (int j = i + 1; j &amp;lt; n; j++) { tmp *= arr[j]; Max = max(Max, tmp); } } printf(&amp;#34;Case #%d: The maximum product is %lld.</description>
    </item>
    
    <item>
      <title>UVA725</title>
      <link>https://haofish.github.io/2020/uva725/</link>
      <pubDate>Thu, 06 Aug 2020 16:25:28 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva725/</guid>
      <description>Division  题意：给你一个数n，让你求出 $abcde / fghij = n$ 的所有结果，a ~ j 的恰好是 0 ~ 9 的数 暴力遍历分子就好了，然后检查分母是否合法就行了  #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; const int M = 1e5; int n; bool check(int a, int b) { bool num[10] = {0}; if (b &amp;lt; 10000) num[0] = true; while (a || b) { num[a % 10] = true; num[b % 10] = true; a /= 10, b /= 10; } int x = 0; for (auto i : num) if (i) x++; return x == 10; } bool check(int a) { bool num[10] = {0}; if (a &amp;lt; 10000) num[0] = true; while (a) { num[a % 10] = true; a /= 10; } int x = 0; for (auto i : num) if (i) x++; return x == 5; } int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.</description>
    </item>
    
    <item>
      <title>UVA10410</title>
      <link>https://haofish.github.io/2020/uva10410/</link>
      <pubDate>Wed, 05 Aug 2020 10:12:16 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva10410/</guid>
      <description>Tree Reconstruction  题意：给你一个DFS和一个BFS遍历的树（具体遍历方式都是小的权值优先），让你求出每个节点的子节点 直接说思路：栈的运用，题目说输出任意可能的答案，所以把树当成一个二叉树来做，bfs本质就是树的一层一层的遍历，当一个节点在bfs序中下标为 $x$，则 $x + 1$可以认为是他的兄弟节点，其后面的都是下层的节点；而dfs的本质是一个链式的深度搜索，也就是说dfs中连续的很可能就是树的一条链式。根据以上性质，用栈来模拟dfs的建造过程，再更具上诉bfs的性质来判断某节点是否是栈顶的一个子节点 代码如下  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int n, x; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  for (; ~scanf(&amp;#34;%d&amp;#34;, &amp;amp;n);) { vector&amp;lt;int&amp;gt; node[1010], dfs(n), bfs(n + 1); for (int i = 1; i &amp;lt;= n; i++) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); bfs[x] = i; } for (auto &amp;amp;i : dfs) scanf(&amp;#34;%d&amp;#34;, &amp;amp;i); stack&amp;lt;int&amp;gt; st; int root = dfs[0]; st.</description>
    </item>
    
    <item>
      <title>UVA806</title>
      <link>https://haofish.github.io/2020/uva806/</link>
      <pubDate>Tue, 04 Aug 2020 18:02:01 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva806/</guid>
      <description>Spatial Structures  类似于计算像素的，读懂题意直接模拟就好了 毒瘤题  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; using ll = long long; int n, kase = 0; char g[70][70], m[70][70]; vector&amp;lt;ll&amp;gt; ans; void dfs(int r1, int c1, int r2, int c2, ll all, int d, int pos) { if (r1 == r2) { if (m[r1][c1] == &amp;#39;1&amp;#39;) ans.push_back(all + pos * pow(5, d - 1)); return; } int sum1 = 0, sum2 = 0, sum3 = 0, sum4 = 0; for (int i = r1; i &amp;lt;= (r2 + r1) / 2; i++) { for (int j = c1; j &amp;lt;= (c2 + c1) / 2; j++) { sum1 += m[i][j] - &amp;#39;0&amp;#39;; } } for (int i = r1; i &amp;lt;= (r2 + r1) / 2; i++) { for (int j = (c1 + c2) / 2 + 1; j &amp;lt;= c2; j++) { sum2 += m[i][j] - &amp;#39;0&amp;#39;; } } for (int i = (r1 + r2) / 2 + 1; i &amp;lt;= r2; i++) { for (int j = c1; j &amp;lt;= (c1 + c2) / 2; j++) { sum3 += m[i][j] - &amp;#39;0&amp;#39;; } } for (int i = (r1 + r2) / 2 + 1; i &amp;lt;= r2; i++) { for (int j = (c1 + c2) / 2 + 1; j &amp;lt;= c2; j++) { sum4 += m[i][j] - &amp;#39;0&amp;#39;; } } int sum = sum1 + sum2 + sum3 + sum4; ll x = 0; if (d) x = all + pos*pow(5, d - 1); if (sum == (r2 - r1 + 1) * (c2 - c1 + 1)) { if (x) ans.</description>
    </item>
    
    <item>
      <title>UVA804</title>
      <link>https://haofish.github.io/2020/uva804/</link>
      <pubDate>Tue, 04 Aug 2020 14:26:40 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva804/</guid>
      <description>Petri Net Simulation  每个T变迁都有限制，必须是指定的P库有足够的token才行（注意，T指定的P库不一定只有一个），直接模拟就好了  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int p[110], np, nt, kase = 0; struct T { int in[110], out[110]; T() { memset(in, 0, sizeof in); memset(out, 0, sizeof out); } }; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  for (; scanf(&amp;#34;%d&amp;#34;, &amp;amp;np), np;) { for (int i = 1; i &amp;lt;= np; i++) { scanf(&amp;#34;%d&amp;#34;, p + i); } scanf(&amp;#34;%d&amp;#34;, &amp;amp;nt); int x; T ts[110]; for (int i = 1; i &amp;lt;= nt; i++) { for (; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x), x;) { if (x &amp;lt; 0) ts[i].</description>
    </item>
    
    <item>
      <title>UVA12166</title>
      <link>https://haofish.github.io/2020/uva12166/</link>
      <pubDate>Mon, 03 Aug 2020 20:27:46 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva12166/</guid>
      <description>Equilibrium Mobile  题意：给你一个天平，修改某些节点可以使得天平平衡，让你求出最小的修改数量 竟然是一道思维题，不行，这题要写写题解 思路：  假设这个数是一个满二叉树的，并且每个叶子节点每个叶子节点的重量（权值）都不一样，则最少的修改次数就是：叶子节点数 - 1，具体策略就是找一个叶子节点为基准点，设其重量为$x$，然后把其余的叶子节点的重量都修改成$x$，设数的深度为$h$，则此时整棵树的的重量为 $x \times 2 ^ {h - 1}$ 对于其他情况，我们可以根据上述的特殊情况来推导，假设以某个叶子节点为基准点，然后计算修改后整棵树的重量（根据公式 $x \times 2 ^ {h - 1}$） 所以策略就是，计算每个叶子节点以其为基准点修改后的整棵树的重量，这样计算下去，可能会出现计算结果相同的情况，就意味着以该叶子节点为基准点修改时，有不需要修改的叶子节点 那么我们就可以统计以每个叶子节点为基准点修改后的整棵树的重量的值，出现最多次数的就说明以该叶子节点为基准点修改，有最多的叶子节点不需要修改，固需要修改的叶子节点个数最少 剩下的就是代码实现了，由于重量可能很大，固用哈希来存放该重量的数量   代码如下  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; using ll = long long; int t, num; char str[1000005]; unordered_map&amp;lt;ll, int&amp;gt; myhash; void dfs(int l, int r, ll d) { if (str[l] == &amp;#39;[&amp;#39;) { int l_indx = l + 1, p = 0; while (l_indx &amp;lt; r) { if (str[l_indx] == &amp;#39;[&amp;#39;) p++; if (str[l_indx] == &amp;#39;]&amp;#39;) p--; if (p == 0) break; l_indx++; } int r_indx = strchr(&amp;amp;str[l_indx], &amp;#39;,&amp;#39;) - &amp;amp;str[l_indx] + l_indx; dfs(l + 1, l_indx, d + 1); dfs(r_indx + 1, r - 1, d + 1); return; } ll w = 0; sscanf(&amp;amp;str[l], &amp;#34;%lld&amp;#34;, &amp;amp;w); myhash[w * (1 &amp;lt;&amp;lt; d)]++; num++; } int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.</description>
    </item>
    
    <item>
      <title>UVA1600</title>
      <link>https://haofish.github.io/2020/uva1600/</link>
      <pubDate>Mon, 03 Aug 2020 16:26:13 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva1600/</guid>
      <description>Patrol Robot  BFS进阶题 题意：有个移动的机器人，从（1， 1）点出发，目标是（m， n）点，0为可以通过的点，1为障碍点，机器人一次最多只能穿越k障碍，问你最少要走多少步到达终点 BFS走，要注意个是要记录到达障碍点的最短穿越障碍个数  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int n, m, g[25][25], t, k; const int dx[] = {-1, 0, 1, 0}; const int dy[] = {0, -1, 0, 1}; inline bool check(int x, int y) { return x &amp;gt;= 1 &amp;amp;&amp;amp; y &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n &amp;amp;&amp;amp; y &amp;lt;= m; } struct coo{ int x, y, d, k; coo(){} coo(int x, int y, int d, int k) : x(x), y(y), d(d), k(k){} }; void bfs() { queue&amp;lt;coo&amp;gt; q; bool vis[25][25][25] = {0}; vis[1][1][0] = g[1][1] == 1; q.</description>
    </item>
    
    <item>
      <title>UVA439</title>
      <link>https://haofish.github.io/2020/uva439/</link>
      <pubDate>Sun, 02 Aug 2020 16:15:00 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva439/</guid>
      <description>Knight Moves  题意：在象棋里，给马的起点和终点，计算最小移动步数  #include &amp;lt;bits/stdc++.h&amp;gt;#define mk(a, b) make_pair(a, b) using namespace std; using pii = pair&amp;lt;int, int&amp;gt;; using pdi = pair&amp;lt;pii, int&amp;gt;; int sx, sy, ex, ey; bool vis[10][10]; char a[5], b[5]; const int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2}; const int dy[] = {-1, -2, -2, -1, 1, 2, 2, 1}; inline bool cherk(int x, int y) { return x &amp;gt; 0 &amp;amp;&amp;amp; y &amp;gt; 0 &amp;amp;&amp;amp; x &amp;lt; 9 &amp;amp;&amp;amp; y &amp;lt; 9; } void print(int num) { printf(&amp;#34;To get from %s to %s takes %d knight moves.</description>
    </item>
    
    <item>
      <title>UVA536</title>
      <link>https://haofish.github.io/2020/uva536/</link>
      <pubDate>Sun, 02 Aug 2020 15:35:18 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva536/</guid>
      <description>Tree Recovery  给你一个二叉树的先序和中序遍历，输出对应的后序遍历  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; char pre[30], in[30]; void dfs(int a, int b, int c, int d) { if (c &amp;gt; d) return; char tmp = pre[a]; int indx = c; while (in[indx] != tmp) indx++; dfs(a + 1, a + indx - c, c, indx - 1); dfs(a + indx - c + 1, b, indx + 1, d); printf(&amp;#34;%c&amp;#34;, tmp); } int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.</description>
    </item>
    
    <item>
      <title>UVA712</title>
      <link>https://haofish.github.io/2020/uva712/</link>
      <pubDate>Sun, 02 Aug 2020 14:41:02 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva712/</guid>
      <description>S-Trees  题意：一棵二叉树，每个层节点都有有个逻辑布尔变量，0往左走，1往右走，给你最后一层的结果值，再给你每个变量的取值，问你最后走到的最后一层叶子节点的值 这题有点迷，一开始忘记记录变量的顺序尽然也过了，后来记录了也能过 不考虑变量的顺序  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int n, k, kase = 0;; char res[600], in[10]; void dfs(int indx, int x) { if (indx == n) { printf(&amp;#34;%c&amp;#34;, res[x - (1 &amp;lt;&amp;lt; n)]); return; } if (in[indx] == &amp;#39;0&amp;#39;) dfs(indx + 1, x &amp;lt;&amp;lt; 1); else dfs(indx + 1, x &amp;lt;&amp;lt; 1 | 1); } int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;n), n) { char tmp[10]; for (int i = 0; i &amp;lt; n; i++) { scanf(&amp;#34;%s&amp;#34;, tmp); } scanf(&amp;#34;%s&amp;#34;, res); printf(&amp;#34;S-Tree #%d:\n&amp;#34;, ++kase); scanf(&amp;#34;%d&amp;#34;, &amp;amp;k); while (k--) { scanf(&amp;#34;%s&amp;#34;, in); dfs(0, 1); } puts(&amp;#34;\n&amp;#34;); } return 0; }  考虑变量的顺序  #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>UVA672</title>
      <link>https://haofish.github.io/2020/uva672/</link>
      <pubDate>Sun, 02 Aug 2020 09:51:25 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva672/</guid>
      <description>Parentheses Balance  让你判断括号是否合法，栈的经典例题  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int t; int main () { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); getchar(); while (t--) { char str[150]; fgets(str, sizeof str, stdin); stack&amp;lt;char&amp;gt; st; for (int i = 0; str[i] != &amp;#39;\n&amp;#39;; i++) { if (str[i] == &amp;#39;)&amp;#39; &amp;amp;&amp;amp; st.size() &amp;amp;&amp;amp; st.top() == &amp;#39;(&amp;#39;) st.pop(); else if (str[i] == &amp;#39;]&amp;#39; &amp;amp;&amp;amp; st.size() &amp;amp;&amp;amp; st.</description>
    </item>
    
    <item>
      <title>UVA816</title>
      <link>https://haofish.github.io/2020/uva816/</link>
      <pubDate>Sat, 01 Aug 2020 15:56:21 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva816/</guid>
      <description>Abbott&amp;rsquo;s Revenge  题意：给你起点和终点，每个点面向不同的方向有不用的指定方向，问你从起点到终点最短路 BFS就好，但是要注意的是每个点都有不用的方向，所以要多加一维来保存这些方向，即每个点相当于是4个点 一道值得学习深究的一题  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const char dis[] = &amp;#34;NESW&amp;#34;, go[] = &amp;#34;RLF&amp;#34;; const int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, 1, 0, -1 }; int sx, sy, rx, ry, ex, ey, rd, d[15][15][4]; bool ok[15][15][4][3]; inline int get_dis(char c) { return strchr(dis, c) - dis; } inline int get_go(char c) { return strchr(go, c) - go; } inline bool cherk(int x, int y) { return x &amp;gt; 0 &amp;amp;&amp;amp; x &amp;lt;= 9 &amp;amp;&amp;amp; y &amp;gt; 0 &amp;amp;&amp;amp; y &amp;lt;= 9; } struct nodes{ int x, y, d; nodes(int x = 0, int y = 0, int d = 0) : x(x), y(y), d(d) {} }pre[15][15][4]; nodes work(nodes &amp;amp;node, int i) { int dr = node.</description>
    </item>
    
    <item>
      <title>UVA10305</title>
      <link>https://haofish.github.io/2020/uva10305/</link>
      <pubDate>Sat, 01 Aug 2020 09:47:35 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva10305/</guid>
      <description>Ordering Tasks  题意：给你一堆未知数的大小关系，让你输出可能的总体大小关系 简化了拓扑排序，只因根据题中的意思了解到一定是DAG  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int M = 110; int m, n, vis[M]; bool g[M][M]; vector&amp;lt;int&amp;gt; ans; void dfs(int u) { vis[u] = true; for (int i = 1; i &amp;lt;= m; i++) { if (!vis[i] &amp;amp;&amp;amp; g[u][i]) { dfs(i); } } ans.push_back(u); } int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;m, &amp;amp;n), m + n) { int x, y; for (int i = 0; i &amp;lt; n; i++) { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;x, &amp;amp;y); g[x][y] = true; } for (int i = 1; i &amp;lt;= m; i++) { if (vis[i]) continue; dfs(i); } reverse(ans.</description>
    </item>
    
    <item>
      <title>UVA572</title>
      <link>https://haofish.github.io/2020/uva572/</link>
      <pubDate>Fri, 31 Jul 2020 20:13:07 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva572/</guid>
      <description>Oil Deposits  给你一个矩形图，让你求连通的“@”块，一个连通的定义是该点的八个方向都是连通的，dfs就行了  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int m, n, cont[110][110]; char g[110][110]; void dfs(int x, int y, int num) { if (x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= m || y &amp;gt;= n || cont[x][y] || g[x][y] != &amp;#39;@&amp;#39;) return; cont[x][y] = num; for (int i = -1; i &amp;lt;= 1; i++) { for (int j = -1; j &amp;lt;= 1; j++) { if (i !</description>
    </item>
    
    <item>
      <title>UVA699</title>
      <link>https://haofish.github.io/2020/uva699/</link>
      <pubDate>Fri, 31 Jul 2020 19:38:47 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva699/</guid>
      <description>The Falling Leaves  二叉树的计算，直接递归读入遍历即可 所有数据要以空行相隔，UVA特色  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int M = 5e5; int node[M], t = 0; void build(int mid) { int v; scanf(&amp;#34;%d&amp;#34;, &amp;amp;v); if (v == -1) return; node[mid] += v; build(mid - 1); build(mid + 1); } bool read() { int v, mid = M &amp;gt;&amp;gt; 1; scanf(&amp;#34;%d&amp;#34;, &amp;amp;v); if (v == -1) return false; memset(node, 0, sizeof node); node[mid] = v; build(mid - 1); build(mid + 1); return true; } int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.</description>
    </item>
    
    <item>
      <title>UVA839</title>
      <link>https://haofish.github.io/2020/uva839/</link>
      <pubDate>Fri, 31 Jul 2020 17:53:32 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva839/</guid>
      <description>Not so Mobile  题意：天平平衡，题意很好懂，就是让你判断给的天平平不平衡，直接递归读入就好了  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int t, w; bool ok; void read(int &amp;amp;w) { int wl, dl, wr, dr; scanf(&amp;#34;%d%d%d%d&amp;#34;, &amp;amp;wl, &amp;amp;dl, &amp;amp;wr, &amp;amp;dr); if (wl == 0) read(wl); if (wr == 0) read(wr); w = wl + wr; if (wl * dl != wr * dr) ok = false; } int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); while (t--) { ok = true; read(w); if (ok) puts(&amp;#34;YES&amp;#34;); else puts(&amp;#34;NO&amp;#34;); if (t) puts(&amp;#34;&amp;#34;); } return 0; }  总结：这题是一个很特殊的树，在输入时就开始递归，值得学习  </description>
    </item>
    
    <item>
      <title>UVA679</title>
      <link>https://haofish.github.io/2020/uva679/</link>
      <pubDate>Fri, 31 Jul 2020 11:53:31 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva679/</guid>
      <description>Dropping Balls  题意：小球在一个二叉树上下落，每个节点都有一个开关，起初全是关的，如果节点是开小球往右走，反之往左走，让你求最后一个球落到了哪个节点 如果直接单纯的模拟是会超时的，观察可以发现一个节点的第奇数个球都会落到左子树，第偶数个球都落到了右边，自己草稿模拟一下就好了 代码如下  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int d, n, t; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); while (t--) { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;d, &amp;amp;n); int ans = 1; for (int i = 1; i &amp;lt; d; i++) { if (n &amp;amp; 1) { ans &amp;lt;&amp;lt;= 1; n = (n + 1) &amp;gt;&amp;gt; 1; } else { ans = ans &amp;lt;&amp;lt; 1 | 1; n &amp;gt;&amp;gt;= 1; } } printf(&amp;#34;%d\n&amp;#34;, ans); } return 0; } </description>
    </item>
    
    <item>
      <title>UVA548</title>
      <link>https://haofish.github.io/2020/uva548/</link>
      <pubDate>Fri, 31 Jul 2020 11:50:26 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva548/</guid>
      <description>Tree  给你二叉树的中序和先序遍历，让你求从根节点到叶节点的的距离权值和最小，如果有多解，叶节点的权值要小，输出叶节点的权值  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int M = 1e4 + 10; string str; int ino[M], posto[M], ans, Max, lson[M], rson[M], len = 0; void dfs(int u, int sum) { if (!lson[u] &amp;amp;&amp;amp; !rson[u]) { if (sum &amp;lt; Max || (sum == Max &amp;amp;&amp;amp; ans &amp;gt; u)) { ans = u, Max = sum; } } if (lson[u] != 0) dfs(lson[u], sum + lson[u]); if (rson[u] !</description>
    </item>
    
    <item>
      <title>UVA514</title>
      <link>https://haofish.github.io/2020/uva514/</link>
      <pubDate>Fri, 31 Jul 2020 11:48:14 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva514/</guid>
      <description>Rails  让你判断列车出站是否正确，栈的运用  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; const int M = 1e3 + 10; int n, arr[M]; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;n), n) { while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;arr[1]), arr[1]) { for (int i = 2; i &amp;lt;= n; i++) { scanf(&amp;#34;%d&amp;#34;, arr + i); } stack&amp;lt;int&amp;gt; st; int in = 1, out = 1; bool ok = true; while (out &amp;lt;= n) { if (in == arr[out]) { in++, out++; } else if (st.</description>
    </item>
    
    <item>
      <title>UVA442</title>
      <link>https://haofish.github.io/2020/uva442/</link>
      <pubDate>Fri, 31 Jul 2020 11:44:20 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva442/</guid>
      <description>Matrix Chain Multiplication  矩阵链乘，栈的运用  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; using pii = pair&amp;lt;int, int&amp;gt;; int n; pii m[30]; char str[100000]; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 0; i &amp;lt; n; i++) { char a; int x, y; scanf(&amp;#34;\n%c%d%d&amp;#34;, &amp;amp;a, &amp;amp;x, &amp;amp;y); m[a - &amp;#39;A&amp;#39;] = make_pair(x, y); } getchar(); while (fgets(str, sizeof str, stdin)) { stack&amp;lt;pii&amp;gt; st; int len = strlen(str), ans = 0; if (str[len - 1] == &amp;#39;\n&amp;#39;) str[len-- - 1] = &amp;#39;\0&amp;#39;; bool ok = true; for (int i = 0; i &amp;lt; len; i++) { if (isalpha(str[i])) { st.</description>
    </item>
    
    <item>
      <title>UVA122</title>
      <link>https://haofish.github.io/2020/uva122/</link>
      <pubDate>Fri, 31 Jul 2020 11:19:07 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/uva122/</guid>
      <description>Trees on the level  二叉树的建立  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int M = 1e5 + 10; int lson[M], rson[M], cnt, node[M]; bool ok, in[M] = {false};//in记录节点是否存在 vector&amp;lt;int&amp;gt; ans; int newnode() {//申请新的地址  int u = ++cnt; lson[u] = rson[u] = 0; return u; } void newtree() {//建新树  lson[1] = rson[1] = 0; in[1] = false; cnt = 1; } void build(int v, char *s) { int indx = 0, u = 1; while (s[indx] !</description>
    </item>
    
    <item>
      <title>贪心刷题总结</title>
      <link>https://haofish.github.io/2020/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 25 Jul 2020 19:08:51 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>前言 总结 普通贪心 Bin Packing 区间贪心 未完待续……  前言  终于开始刷贪心了，感觉cf很多题都喜欢出贪心，所以决定也练练 贪心貌似也有挺系统的分类和一些经典例题，把这些刷了应该就有提升了把  总结  贪心是指将问题通过当前最优解来求解得到最终的最优解，即局部最优解可以推出总体最优解。 给我的感觉就是一种思维题，通过一定技巧把题目旁敲侧击地解决了，但是如果没接触过或者想不出来，基本就很难了，但是贪心的代码实现并不长，所以说贪心即使很基础的算法也是很难的算法。 总得来说贪心算法难就难在每道题的贪心策略都不同，是否能贪心也很难看出来。 一般在解决贪心题的时候可以把他放到生活中的例子来，想想如果是生活中碰到这题，你会怎么解决让自己最舒服。  普通贪心   【例题】
  HDU 2111 Saving HDU
 题意：你有可以装k个宝贝容量的包，现在给你一些宝贝，每个宝贝价值p，有m个，问你最多可以装多少价值的宝贝 思路：将价值排序，先选大的，选到v = 0为止 代码如下  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;utility&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; int n, v; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;v), v) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; for (int i = 0; i &amp;lt; n; i++) { int p, m; scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;p, &amp;amp;m); q.</description>
    </item>
    
    <item>
      <title>Olympiad</title>
      <link>https://haofish.github.io/2020/olympiad/</link>
      <pubDate>Fri, 24 Jul 2020 19:25:00 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/olympiad/</guid>
      <description>传送门  题意：给你两个同长数组代表n个人两场比赛的成绩，再给你一个x，某两个数组的和$a_i + b_j \ge x$，问你两数组组合成满足式子的排名最高和最低是多少。具体看样例就懂了。 思路：此题对于最高排名一定是1，即第一名，而最低排名的话，一开始知道是一个双指针的贪心，但是就是不知道怎么贪，后来看到大佬的想法豁然开朗：只要找到组合后大于等于x的个数有多少就好了。 具体找法：一个数组a大到小排序，一个数组b小到大排序，然后只要从a从头开始一个一个遍历，从b数组中从头找能与a数组的数加起来大于等于x的数就好了，然后记录个数，就是答案 心得：贪心题目是难想，想到之后就很简单，代码量也不大，还有一个比较考验的就是模拟的功力了（从人的思维去想想如果这不是一道编程题，而是一个生活的益智题，你会怎么做？然后再用代码实现,说的简单，感觉还是要多刷题） 代码如下  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt; using namespace std; const int M = 1e5 + 5; int n, x, a[M], b[M]; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;x); for (int i = 0; i &amp;lt; n; i++) { scanf(&amp;#34;%d&amp;#34;, a + i); } for (int i = 0; i &amp;lt; n; i++) { scanf(&amp;#34;%d&amp;#34;, b + i); } printf(&amp;#34;1 &amp;#34;); sort(a, a + n); sort(b, b + n); reverse(a, a + n); //a从大到小排序  int j = 0, ans = 0; for (int i = 0; i &amp;lt; n; i++) { while (j &amp;lt; n &amp;amp;&amp;amp; b[j] + a[i] &amp;lt; x) { j++; } if (j &amp;gt;= n) break; ans++; j++; } printf(&amp;#34;%d&amp;#34;, ans); return 0; } </description>
    </item>
    
    <item>
      <title>Cosmic_Tables</title>
      <link>https://haofish.github.io/2020/cosmic_tables/</link>
      <pubDate>Fri, 24 Jul 2020 16:26:14 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/cosmic_tables/</guid>
      <description>传送门  题意：给你一个矩阵，每次进行与行之间的交换，或者是列与列之间的交换，或者查询(x, y)点的值 思路：一开始想着是不是直接就纯模拟算了，后来想想，直接用数组把行和列也记录下来不就好了吗 代码如下  #include &amp;lt;cstdio&amp;gt; using namespace std; const int M = 1e3 + 10; int r[M], c[M], g[M][M], n, m, k; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;n, &amp;amp;m, &amp;amp;k); for (int i = 1; i &amp;lt;= n; i++) r[i] = i; for (int i = 1; i &amp;lt;= m; i++) c[i] = i; for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= m; j++) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;g[i][j]); } } while (k--) { char a; int x, y; scanf(&amp;#34;\n%c %d %d&amp;#34;, &amp;amp;a, &amp;amp;x, &amp;amp;y); if (a == &amp;#39;r&amp;#39;) {//交换操作  r[x] ^= r[y], r[y] ^= r[x], r[x] ^= r[y]; } else if (a == &amp;#39;c&amp;#39;) { c[x] ^= c[y], c[y] ^= c[x], c[x] ^= c[y]; } else { printf(&amp;#34;%d\n&amp;#34;, g[r[x]][c[y]]); } } return 0; } </description>
    </item>
    
    <item>
      <title>Shooshuns_and_Sequence</title>
      <link>https://haofish.github.io/2020/shooshuns_and_sequence/</link>
      <pubDate>Fri, 24 Jul 2020 15:15:22 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/shooshuns_and_sequence/</guid>
      <description>传送门  什么鬼，div2也出水题？还是我变强了？😂 题意：给你一个长为n的序列，再给你一个k，你每次都必须要这样做：选择第k个数，把他复制到序列的最后，再把序列的第一个数给删了，问你要操作多少次可以使得序列数组的数全部相同，如果根本不可能通过上述操作使得序列数组的数全部相同，则输出-1 思路：不难发现，如果一开始第k个数及后面的数有出现不同的数的话，是不可能通过上述操作使得整个数组完全相同，如果可能的话，就往k前找，即往左找，找到第一个与第k个数不同的数，输出他的下标就好了（因为要一直删到那个不同的数），模拟一下就好了。 代码如下  #include &amp;lt;cstdio&amp;gt; using namespace std; const int M = 1e5 + 10; int n, k, arr[M]; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;k); for (int i = 0; i &amp;lt; n; i++) { scanf(&amp;#34;%d&amp;#34;, arr + i); } int tmp = arr[k - 1]; for (int i = k; i &amp;lt; n; i++) { if (arr[i] !</description>
    </item>
    
    <item>
      <title>Tourist&#39;s_Notes</title>
      <link>https://haofish.github.io/2020/tourists_notes/</link>
      <pubDate>Fri, 24 Jul 2020 09:56:16 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/tourists_notes/</guid>
      <description>传送门  题意：旅行者每天都会记录自己的海拔高度，他每天规定走海拔相差不超过1的路线，有一天他的记录丢失了，只剩下几天的，问你他之前有可能到达的最高海拔是多少，如果数据出现矛盾，输出&amp;quot;IMPOSSIBLE&amp;rdquo; 思路：用两个数组记录天数和当天的海拔高度，如果相隔的海拔差比相隔的天数差还大的话就是矛盾，否则就这样计算相隔天数中可能的最大海拔高度：$MaxHight = ( day[i] + hight[i] - (day[i - 1] - hight[i - 1]) ) / 2$，最后取众多MaxHight的最大值 注意：第一天和最后一天的数据可能没给，所以我们要自己造一个可能的最大高度，例如只给你第3天的海拔高度为5，总共旅行的天数为4，那么我们就自己造一个第一天的高度为7$(5 + 3 - 1)$，第4天的高度为6$(5 + (4 - 3))$，就是一开始没想到这个，wa了2发/(ㄒoㄒ)/~~ 代码如下：  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; const int M = 1e5 + 10; int n, m, d[M], h[M]; bool ok = true; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); for (int i = 1; i &amp;lt;= m; i++) { scanf(&amp;#34;%d%d&amp;#34;, d + i, h + i); if (i !</description>
    </item>
    
    <item>
      <title>Quasi_Binary</title>
      <link>https://haofish.github.io/2020/quasi_binary/</link>
      <pubDate>Thu, 23 Jul 2020 21:08:02 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/quasi_binary/</guid>
      <description>传送门  题意：一个只由1和0组成的十进制数叫做Quasi Binary，例如11（十一）就是，现在给你一个n，让你求出他可能有哪些Quasi Binary的和组成，输出最少的Quasi Binary个数并将他们输出 思路：模拟，用个二维数组记录所有的结果位数结果，然后相加输出。例如32就是记录10、10、10、1、1，然后分别将不同位数的相加得到11（10 + 1），11（10 + 1），10（10 + 0） 代码如下  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); int t = n, sum = 0; while (t) { sum = max(t % 10, sum); t /= 10; } printf(&amp;#34;%d\n&amp;#34;, sum); int tmp, x = 0, y = 0, numset[7][10] = {0}, w = 1; while (n) { tmp = n % 10, y = 0; while (tmp) { numset[x][y++] = w; tmp--; } n /= 10, x++, w *= 10; } for (int i = 0; i &amp;lt; sum; i++) { int res = 0; for (int j = 0; j &amp;lt; 7; j++) { res += numset[j][i]; } printf(&amp;#34;%d &amp;#34;, res); } return 0; } </description>
    </item>
    
    <item>
      <title>Cutting_Banner</title>
      <link>https://haofish.github.io/2020/cutting_banner/</link>
      <pubDate>Thu, 23 Jul 2020 20:08:59 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/cutting_banner/</guid>
      <description>传送门  题意：给你个字符串，减去一段子串，是否能将剩下的不改变顺序拼成&amp;quot;CODEFORCES&amp;rdquo;，能则输出&amp;quot;YES&amp;rdquo;，否则输出&amp;quot;NO&amp;rdquo; 思路：直接枚举减去的长度，然后暴力 代码如下  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; char aim[] = &amp;#34;CODEFORCES&amp;#34;, str[200], tmp[200]; int main() { #ifndef ONLINE_JUDGE  freopen(&amp;#34;test.in&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;test.out&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif  scanf(&amp;#34;%s&amp;#34;, str); if (strcmp(str, aim) == 0) { puts(&amp;#34;YES&amp;#34;); return 0; } int len = strlen(str); for (int i = 1; i &amp;lt;= len; i++) { for (int j = 0; j + i - 1 &amp;lt; len; j++) { int ind = 0; for (int k = 0; k &amp;lt; len; k++) { if (k &amp;lt; j || k &amp;gt; j + i - 1) { tmp[ind++] = str[k]; } } tmp[ind] = &amp;#39;\0&amp;#39;; if (strcmp(tmp, aim) == 0) { puts(&amp;#34;YES&amp;#34;); return 0; } } } puts(&amp;#34;NO&amp;#34;); return 0; } </description>
    </item>
    
    <item>
      <title>图论刷题总结</title>
      <link>https://haofish.github.io/2020/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 21 Jul 2020 22:22:01 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>前言 总结 最短路  Dijkstra Bellman-Ford Floyd Spfa   未完待续  前言  起因是一次力扣周赛时被一道最短论的题给整蒙了，决定这几天恶补图论，正好POJ的刷题题单刷到了图 打算学习图论从零开始，目前刷的题不多  总结  关于存图  不同的存图方式可以使得不同的算法更加方便，例如：邻接表可以使Dijkstra算法在堆优化中方便不少，而邻接矩阵可以使Floyd算法更加方便   关于建图  有一些题目在描述的时候给的数据不好建图，这需要经验的积累 而有一些题目并没有直接说明是图，换句话说能否看出是使用图论的知识来解题也需要经验的累积   关于计算  题目中的要求并不是一成不变的，有时候最短路径并不是仅仅指的是值最短，有时候也有可能题目让你求最大值，但最短路依然可以解    最短路  先从最短路开始刷，刷到后面发现有些题三个算法（Dijkstra、Bellman-Ford、Floyd）都是可以解的  Dijkstra   [例题]
  洛谷P4779 【模板】单源最短路径（标准版）
 题意：最短路板子题，不解释 思路：直接用Dijkstra的堆优化做，因为没有负环 直接上代码  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;locale&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;utility&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef long long ll; typedef pair&amp;lt;int, int&amp;gt; pii; const int M = 2e5 + 10; const ll INF = 0x3f3f3f3f; int n, m, s, cnt = 0; struct edges { int w, to, next; edges(int a = 0, int b = 0, int c = -1) : w(b), to(a), next(c) {} }; vector&amp;lt;int&amp;gt; head, dis; vector&amp;lt;edges&amp;gt; edge; inline void add(int u, int v, int w) { edge[++cnt] = edges(v, w, head[u]); head[u] = cnt; } void dij() { vector&amp;lt;bool&amp;gt; vis(n + 1, false); dis = vector&amp;lt;int&amp;gt;(n + 1, INF); priority_queue&amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt; heap; dis[s] = 0; heap.</description>
    </item>
    
    <item>
      <title>模板</title>
      <link>https://haofish.github.io/2020/%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Mon, 13 Jul 2020 17:12:35 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/%E6%A8%A1%E6%9D%BF/</guid>
      <description>基础  二分 快速幂 最大公因数，最小公倍数 素数筛（埃式） 高精（不压位） 高精（压位） 离散化 未完待续……   数据结构  树状数组 线段树 简单的整数哈希（二进制版线性探查） dijkstra(堆优化版) bellman - ford floyd    基础 二分    二分分法：[l, mid) 和 [mid, r],目标值符合右区间及其端点    int bsearch(int l, int r){ while (l &amp;lt; r) { int mid = (long long)(l + r) &amp;gt;&amp;gt; 1;//相当于 l + r 后向下取整  if (/* 探针落在左区间 */) l = mid + 1; else r = mid; } return l; }   二分分法：[l, mid] 和 (mid, r], 目标值符合左区间及其端点    int bsearch(int l, int r){ while (l &amp;lt; r) { int mid = (long long)(l + r + 1) &amp;gt;&amp;gt; 1; //相当于 l + r 后向上取整，否则陷入死循环，例如 此时 l = 1, r = 2, 那么探针就会一直落到左区间 l 上（l + r &amp;gt;&amp;gt; 1 = 1），下一步 l = mid = l,就会死循环  if (/* 探针落在左区间 */) l = mid; else r = mid - 1; } return l; } 二分参考资料</description>
    </item>
    
    <item>
      <title>C. A Cookie for You题解</title>
      <link>https://haofish.github.io/2020/654div2problemc/</link>
      <pubDate>Mon, 06 Jul 2020 20:28:19 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/654div2problemc/</guid>
      <description>传送门
题意  有 a 个 饼干，和 b 个巧克力 有 n 个 第一类人，有 m 个第二类人  对于第一类人， if (a &amp;gt; b)吃一个饼干，else 吃一个巧克力 对于第二类人， if (a &amp;gt; b)吃一个巧克力，else 吃一个饼干   问你是否有一种方法能让第一类和第二类人都有东西吃，有输出Yes，否则输出No  思考  很显然第一类人优先吃多的（一样多就吃巧克力），第二类人优先吃少的（一样多就吃饼干） 有两种思路，一个是我自己比赛时想到的，一个是x大佬讲的 方法一  一来就判断饼干和巧克力的总数够不够第一类和第二类人吃，如果不够，直接No，如果够如下 先让第二类人吃，方便我们思考，因为东西只会被越吃越少嘛，不可能越吃越多，所以他自始至终都会不会换别的吃 然后就是判断最少的是否够第二类人吃。先讨论最简单的——够，显然如果够的话则第一类人一定够吃，为什么，因为第一类人是优先吃最多的，而我们先判断的是总数都够吃，所以无论怎么吃，不管最多的东西怎么变化，都是够吃的,所以是Yes； 但是如果不够吃呢，直接就是No，为什么，解释起来有点麻烦（比赛时候我就是这里没有想好，一直往别的地方想，自己扰乱了自己的思维）。先这样想，如果不够吃，那么最小的永远都是那一个（饼干或者巧克力一开始最少的）：因为不够吃，所以那一个就会被吃完（即等于0），但是呢第二类人还有没吃到的，他们只会吃最少的那一个，而最少的那一个个数是0了，所以无论如何都吃不了了。 比赛的时候我往别的地方想了（相信不止我会这样想歪，现在想通了，解释一下，可能会有点啰嗦）：就是如果最少的不够第二类人吃的话那就一开始先让第一类人吃，或者中途到了某个关系后交替来吃。但是这样只会让自己陷入窘境，其实这种情况下，无论是让第一类人先吃，还是交替吃，都不会改变第二类人没得吃的结果。因为第一类人的插入只会让最多数量的那个东西变少，一直吃到饼干和巧克力个数一样时，最少的个数依然是最少，即便最少的种类可能会变，但是第二类人能吃的个数不会变。换句话说就是，即便它最少或最多的种类转移了，第二类依然会吃最少的，他不可能可以多吃一个多的那一个（即便饼干和巧克力相等） 详细见代码solve()函数   方法二  第一步和方法一相同，总数不够就No，否则如下 利用一个小规律：先让第二类人吃一次，再让第一类人吃一次，这样的话无论两者大小，饼干数和巧克力数都会各自减一。利用这个特点把人和东西给简化。 第一种可能，东西（饼干或者巧克力）优先有一方优先减到0，而两类人都还有，那么一定是No，因为第二类人只吃最少的，而最少的为0了 第二种可能就是，人优先有一方减到了0，这时候如果是第二类人减到了0，显然就是Yes（道理和方法一中最少数量的东西够第一类人吃是一样的）。如果是第一类人减到了0，那么也就是说只剩下第二类人，因为第二类人只吃最少的，所以只要判断最少的那个东西够不够第二类人吃就行了，够就Yes，不够就No 详细见代码solve2()函数   代码如下  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long ll; typedef vector&amp;lt;int&amp;gt; vi; typedef vector&amp;lt;long long&amp;gt; vll; typedef pair&amp;lt;int, int&amp;gt; pii; typedef pair&amp;lt;long long, long long&amp;gt; pll; #define debug printf(&amp;#34;(hao)&amp;#34;) #define all(x) x.</description>
    </item>
    
    <item>
      <title>E1. Reading Books (easy version)题解</title>
      <link>https://haofish.github.io/2020/653div3probleme1/</link>
      <pubDate>Mon, 06 Jul 2020 18:00:01 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/653div3probleme1/</guid>
      <description>传送门
题意  小A和小B要读书，现在共又 n 本书，对于每本书都有三个参数，$t_i$：阅读的时间、$a_i$：小A喜欢读的书、$b_i$：小B喜欢读的书 现在小A和小B都要读 k 本书，但是他俩只读自己喜欢的书 问你小A和小B最少要读多久可以读到 k 本书，（对于都喜欢的书，时间是可以只算一次的） 如果他俩有一个没读到 k 本书就输出 -1  思路  一道思维贪心题cf好狠呀，网上有很多的解法，大多数都是模拟+贪心，但是我看到了一位大佬的贪心思路，醍醐灌顶，下面就用它的思路了 对于每个书本可以分为以下四类  小A和小B都喜欢的书 只有小A喜欢的书 只有小B喜欢的书 他俩都不喜欢的书   显然最后一类可以不管不要呀，看书长知识，目前只考虑第二三类的书，可以分别用数组$a_n$和$b_n$记录这些书的阅读时间，然后从小到大排序，精彩的来了，把$a_i 和 b_i$合成一本书当作是第一类的书（妙呀,我怎么没想到，太笨了，太菜了，刷题少），然后放入第一类，再来对第一类的书的阅读时间排序，选前 k 个书，记录阅读时间就是最终答案 代码如下  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long ll; typedef vector&amp;lt;int&amp;gt; vi; typedef vector&amp;lt;long long&amp;gt; vll; typedef pair&amp;lt;int, int&amp;gt; pii; typedef pair&amp;lt;long long, long long&amp;gt; pll; #define debug printf(&amp;#34;(hao)&amp;#34;) #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i &amp;lt; (b); i++) #define clr(a, v) memset(a, v, sizeof(a))  const int M = 2e5 + 10; vi a, b, t; void solve() { int n, k; scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;k); rep(i, 0, n) { int _t, _a, _b; scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;_t, &amp;amp;_a, &amp;amp;_b); if (_a &amp;amp;&amp;amp; _b) t.</description>
    </item>
    
    <item>
      <title>D. Zero Remainder Array题解</title>
      <link>https://haofish.github.io/2020/653div3problemd/</link>
      <pubDate>Mon, 06 Jul 2020 16:58:31 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/653div3problemd/</guid>
      <description>传送门
题意  给你一个长度为 n 的数组$a_n$，和一个 k，你有一个 x（一开始为0），你有以下两种操作  给 x 加上 1，即$x = x + 1$ 选择一个任意一个$a_i$($0 \le i &amp;lt; n$)加上 x，然后 x 加上 1   每个元素最多只能被执行一次上诉操作 问你执行上述操作，x 最小为多少可以使得数组所有元素都能整除 k  思路  记录数组的每一个数至少要加多少才可以被 k 整除 寻找上述数中的最大的众数，计算 x 加到多少才可以使得这些数都能被 k 整除。 例如  对于一个数组 {1，1，1，2，3}，k = 6 则其至少要加的数为 {5，5，5，4，3} 显然最大的众数是 5，其个数是 3，那么对于第一个 5 则需要把 x 加到 5 就行了，对于第二个 5 ，就需要再等到下一个能模 6 为 5 的数，显然就是11($5 + 6 = 11$), 而第三个 5 也是同理就是 17，但这个还不是最终答案，因为题目的第二个操作是先给数组加上 x，再让 $x + 1$,所以最终答案就是 18   为什么这样就是对的呢？很简单，如果想要执行题中把所有数都弄成可以整除 k 并且每个数只能执行一次，对于两个相同且不能被 k 整除的数 y，想要把这两个 y 都弄成能被 k 整除，第二个数 y 一定要等到下一次有一个数 x 加上这个 y 使得它能整除 k。 所以我们要求出每个数最少加多少才可以被 k 整除，然后求一个最大的众数，计算最后一个众数需要的最小x（因为最后的 x 一定是停在了能使这些最大众数的最后一个数被 k 整除的结果），记得最后的答案要再加一才是最终答案。 那么其余的非最大众数呢？别担心，这些数在为最大众数服务的时候就能有一个 x 使得他们的一些能被 k 整除。例如上面的例子，我们在把 x 走到 5 的之前就有个4，可以使得数组中的 2 加上这个 4 能被 6 整除 还想不明白就想想模数具有周期性，例如将0 ~ n中的数都摸上 3 ，就会有这么一个规律 ：0 1 2 0 1 2 0 1 2 0 1 2····· 代码如下（求众数有点滑稽，因为我不会利用简单代码的求众数的方法）  #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>C. Move Brackets题解</title>
      <link>https://haofish.github.io/2020/653div3problemc/</link>
      <pubDate>Mon, 06 Jul 2020 15:59:43 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/653div3problemc/</guid>
      <description>传送门
题意  给你一串字符串，只有&amp;rdquo;(&amp;rdquo; h和&amp;rdquo;)&amp;ldquo;组成，你每次都能选择一个字符把它移到最左边或者最右边，问你最少移动几次可以使得字符串的括号合法  思路  一道贪心题（比赛的时候没看出来，太菜了😭） 只要计算出合法的括号对，然后用总长度减去合法的括号对的个数，即剩余的不合法长度除以 2 就是最少的步数 例如 ： &amp;ldquo;()))))((((()&amp;rdquo;, 去掉合法的后就是&amp;rdquo;))))((((&amp;rdquo;, 那么移动的长度就是$8 \div 2 = 4$就是答案 这题我一开始想复杂了，对于上一个样例，我以为必须要把下标为2 ~ 5（从0开始）的先一道最左边，再把（原本的）6 ~ 9移到最左边，变成这样：&amp;quot;(((())))()()&amp;quot;,总次数是8，所以就很搞了，然而正确答案是把6 ~ 9 移到最左边就合法了，就是这样：&amp;quot;((((()))))()&amp;quot;,总次数就是 4 所以最终的思路就是判断合法的有多少对：在博客中遇到了两种方法，一种是用栈，一种是不用栈（根据括号合法的特性一定要左括号先出现， 即从头到尾遍历，用一个变量来储存左括号出现次数，一旦遇到右括号变量值就自减） 代码如下（用栈）：  #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef long long ll; typedef vector&amp;lt;int&amp;gt; vi; #define debug printf(&amp;#34;(hao)&amp;#34;) #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i &amp;lt; (b); i++) #define clr(a, v) memset(a, v, sizeof(a))  void solve() { int n; char bra[55]; stack&amp;lt;char&amp;gt; res; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); scanf(&amp;#34;%s&amp;#34;, bra); for (int i = 0; i &amp;lt; n; i++) { if (res.</description>
    </item>
    
    <item>
      <title>B. Multiply by 2, divide by 6题解</title>
      <link>https://haofish.github.io/2020/653div3problemb/</link>
      <pubDate>Mon, 06 Jul 2020 15:01:02 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/653div3problemb/</guid>
      <description>传送门
题意  给一个数 n,问你只进行以下两种操作，要操作最少多少次能够使得 n 为 1：  把 n 除以 6 （前提是可以整除） 把 n 乘 2   输出最少的操作次数，如果无论如何都没办法得到 1，则输出 -1  思路  首先要知道的是，如果对一个数同时进行两个操作就相当于对 n 除以 3 思考一个极端的例子就是：n 的质因子只有 3，那么它一定可以最终得到 1。为什么呢？因为我们可以让每个 3 都乘 2， 这样他就有了因子 6， 便可以做第一个操作了，并且最终得到 1 如果这个数既有 2 又有 3 怎么办？ 很简单，只需要把一对 2 和 3 看成 6，最终剩下的因子如果是 2（因为已经无望再去除以 6 了），则不可能得到 1，如果是 3， 则当成只有因子 3 的数看待（即上述的极端情况） 最后一种情况就是 n 的质因子除了 3 和 2 还有其他的质因子的话，一定最终无法得到 1 所以最终的想法就是：计算出质因子 2 的个数a，和计算出质因子 3 的个数 b, 如果 $a &amp;gt; b$ 则无法得到 1，否则要操作的次数最少为 $(b - a) \times 2 + a$ 代码如下  #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>Dp总结</title>
      <link>https://haofish.github.io/2020/dp%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 01 Jul 2020 11:31:33 +0800</pubDate>
      
      <guid>https://haofish.github.io/2020/dp%E6%80%BB%E7%BB%93/</guid>
      <description>1. 写在前面的话 2. 对DP简单的总结 3. 几个重要的模型  数塔模型  【例题】HDU 2084 数塔   凑硬币模型  【例题1】leetcode 322 零钱兑换 【例题2】leetcode 279 完全平方数   LIS模型  【例题1】leetcode 300 最长上升子序列   LCS模型  【例题1】AcWing 897. 最长公共子序列   背包模型 DAG模型  【例题1】UVA 1025 A Spy in the Metro 【例子2】UVA 437 The Tower of Babylon 【例题3】UVA 116 Unidirectional TSP 【例题4】UVA 12563 Jin Ge Jin Qu hao     4.</description>
    </item>
    
    <item>
      <title>动态规划刷题总结</title>
      <link>https://haofish.github.io/2020/dynamicprogramming/</link>
      <pubDate>Sat, 27 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://haofish.github.io/2020/dynamicprogramming/</guid>
      <description>1、写在前面 2、我对dp的看法和理解 3、典型例题  ①爬楼梯（leetcode #70）  题意 分析 小结      1、写在前面 这几天疯狂刷leetcode的dp题，刷到我都想吐了，看到一个题就先往dp想，感觉中毒不浅，话不多说，赶紧开始总结一下我的成长历程心得。
2、我对dp的看法和理解   首先引入《算法笔记》里的一句话:
 动态规划是一种非常精妙的算法思想，他没有固定的写法、极其灵活，常常需要具体问题具体分析。
 没错正式这种具体问题具体分析的设定让我刷到吐了
  平时在思考动态规划的往往是利用一个小小的公式：递推 = 递归 + 记忆化（下面会赘述我是怎么利用这个公式思考的）
  虽然他是这么说，但是我还是觉得dp的是有套路可循的，例如给dp分类 （背包dp、树形dp、区间dp……），经典题的记忆 （爬楼梯、树塔问题、LIS……）
  一般来说，我思考dp都是从结果往前想的（即从末尾开始想）
  dp的基本使用条件： 1. 拥有重叠子问题、 2. 最优子结构、3.无后效性
  dp思考三步走： 1. 状态定义 → 2.列状态转移方程 → 3.验证方程
  我觉得的动规成长路线：小白 → 利用小公式辅助建立dp → 正常dp三步走思维思考 → 大佬 （我还没触及 将来一定达到( ఠൠఠ )ﾉ）</description>
    </item>
    
  </channel>
</rss>